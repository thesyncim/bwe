---
phase: 02-rate-control-remb
plan: 05
type: execute
wave: 3
depends_on: ["02-01", "02-02"]
files_modified:
  - pkg/bwe/bandwidth_estimator.go
  - pkg/bwe/bandwidth_estimator_test.go
autonomous: true

must_haves:
  truths:
    - "BandwidthEstimator accepts packets via OnPacket() and returns bandwidth estimates"
    - "BandwidthEstimator has no Pion dependencies (standalone core library)"
    - "OnPacket accepts arrival time, send time, payload size, SSRC"
    - "GetEstimate returns bandwidth in bits per second"
    - "Estimator combines delay detection, rate measurement, and rate control"
  artifacts:
    - path: "pkg/bwe/bandwidth_estimator.go"
      provides: "Standalone Estimator API (CORE-01, CORE-02, CORE-03)"
      exports: ["BandwidthEstimatorConfig", "BandwidthEstimator", "OnPacket", "GetEstimate"]
    - path: "pkg/bwe/bandwidth_estimator_test.go"
      provides: "Unit tests for bandwidth estimator"
      min_lines: 150
  key_links:
    - from: "pkg/bwe/bandwidth_estimator.go"
      to: "pkg/bwe/estimator.go"
      via: "DelayEstimator for congestion signals"
      pattern: "DelayEstimator"
    - from: "pkg/bwe/bandwidth_estimator.go"
      to: "pkg/bwe/rate_stats.go"
      via: "RateStats for incoming rate"
      pattern: "RateStats"
    - from: "pkg/bwe/bandwidth_estimator.go"
      to: "pkg/bwe/rate_controller.go"
      via: "RateController for estimate"
      pattern: "RateController"
---

<objective>
Implement the standalone BandwidthEstimator API that combines all components.

Purpose: Provide the core library API (CORE-01, CORE-02, CORE-03) that accepts packets and produces bandwidth estimates. This is the main entry point for bandwidth estimation, with no Pion dependencies.

Output: BandwidthEstimator that wires together DelayEstimator (Phase 1), RateStats (Plan 01), and RateController (Plan 02) into a cohesive API.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-rate-control-remb/02-RESEARCH.md

# Phase 1 components
@pkg/bwe/types.go
@pkg/bwe/estimator.go

# Phase 2 components (Plans 01, 02)
# Will use rate_stats.go and rate_controller.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BandwidthEstimator implementation</name>
  <files>pkg/bwe/bandwidth_estimator.go</files>
  <action>
Create `pkg/bwe/bandwidth_estimator.go` implementing the full estimation pipeline.

```go
package bwe

import (
    "time"

    "multicodecsimulcast/pkg/bwe/internal"
)

// BandwidthEstimatorConfig configures the complete bandwidth estimator.
type BandwidthEstimatorConfig struct {
    // DelayConfig configures the delay-based detector.
    DelayConfig DelayEstimatorConfig

    // RateStatsConfig configures incoming rate measurement.
    RateStatsConfig RateStatsConfig

    // RateControllerConfig configures the AIMD rate controller.
    RateControllerConfig RateControllerConfig
}

// DefaultBandwidthEstimatorConfig returns default configuration.
func DefaultBandwidthEstimatorConfig() BandwidthEstimatorConfig {
    return BandwidthEstimatorConfig{
        DelayConfig:          DefaultDelayEstimatorConfig(),
        RateStatsConfig:      DefaultRateStatsConfig(),
        RateControllerConfig: DefaultRateControllerConfig(),
    }
}

// BandwidthEstimator is the main entry point for bandwidth estimation.
// It combines:
//   - DelayEstimator for congestion signal detection
//   - RateStats for incoming bitrate measurement
//   - RateController for AIMD-based bandwidth estimation
//
// This is a standalone core library with NO Pion dependencies.
type BandwidthEstimator struct {
    config         BandwidthEstimatorConfig
    clock          internal.Clock
    delayEstimator *DelayEstimator
    rateStats      *RateStats
    rateController *RateController

    // Current state
    estimate int64
    ssrcs    map[uint32]struct{} // Track seen SSRCs
}

// NewBandwidthEstimator creates a new bandwidth estimator.
// If clock is nil, a default MonotonicClock is used.
func NewBandwidthEstimator(config BandwidthEstimatorConfig, clock internal.Clock) *BandwidthEstimator {
    if clock == nil {
        clock = internal.MonotonicClock{}
    }

    return &BandwidthEstimator{
        config:         config,
        clock:          clock,
        delayEstimator: NewDelayEstimator(config.DelayConfig, clock),
        rateStats:      NewRateStats(config.RateStatsConfig),
        rateController: NewRateController(config.RateControllerConfig),
        estimate:       config.RateControllerConfig.InitialBitrate,
        ssrcs:          make(map[uint32]struct{}),
    }
}

// OnPacket processes a received packet and updates the bandwidth estimate.
// This is the main entry point - call this for every received RTP packet.
//
// Parameters:
//   - pkt: Packet information (arrival time, send time, size, SSRC)
//
// Returns the current bandwidth estimate in bits per second.
func (e *BandwidthEstimator) OnPacket(pkt PacketInfo) int64 {
    // Track SSRC
    e.ssrcs[pkt.SSRC] = struct{}{}

    // Update incoming rate measurement
    e.rateStats.Update(int64(pkt.Size), pkt.ArrivalTime)

    // Get congestion signal from delay estimator
    signal := e.delayEstimator.OnPacket(pkt)

    // Get measured incoming rate
    incomingRate, ok := e.rateStats.Rate(pkt.ArrivalTime)
    if !ok {
        // Not enough data for rate measurement yet
        // Keep current estimate
        return e.estimate
    }

    // Update rate controller with signal and incoming rate
    e.estimate = e.rateController.Update(signal, incomingRate, pkt.ArrivalTime)

    return e.estimate
}

// GetEstimate returns the current bandwidth estimate in bits per second.
// Call this at any time to get the latest estimate without processing a packet.
func (e *BandwidthEstimator) GetEstimate() int64 {
    return e.estimate
}

// GetSSRCs returns the list of SSRCs seen so far.
// This is useful for building REMB packets.
func (e *BandwidthEstimator) GetSSRCs() []uint32 {
    result := make([]uint32, 0, len(e.ssrcs))
    for ssrc := range e.ssrcs {
        result = append(result, ssrc)
    }
    return result
}

// GetCongestionState returns the current congestion state.
func (e *BandwidthEstimator) GetCongestionState() BandwidthUsage {
    return e.delayEstimator.State()
}

// GetRateControlState returns the current AIMD rate control state.
func (e *BandwidthEstimator) GetRateControlState() RateControlState {
    return e.rateController.State()
}

// GetIncomingRate returns the measured incoming bitrate in bits per second.
// Returns (rate, true) if available, (0, false) otherwise.
func (e *BandwidthEstimator) GetIncomingRate() (int64, bool) {
    return e.rateStats.Rate(e.clock.Now())
}

// Reset resets the estimator to initial state.
// Call this when switching streams or after extended silence.
func (e *BandwidthEstimator) Reset() {
    e.delayEstimator.Reset()
    e.rateStats.Reset()
    e.rateController.Reset()
    e.estimate = e.config.RateControllerConfig.InitialBitrate
    e.ssrcs = make(map[uint32]struct{})
}
```

Key design:
- Single OnPacket() entry point
- GetEstimate() for query without processing
- Wires together all Phase 1 + Phase 2 components
- Tracks SSRCs for REMB building (Plan 06)
- No Pion imports (standalone core)
  </action>
  <verify>
```bash
grep -E "^func|^type" pkg/bwe/bandwidth_estimator.go
```
Should show: BandwidthEstimatorConfig, BandwidthEstimator, NewBandwidthEstimator, OnPacket, GetEstimate, GetSSRCs, GetCongestionState, GetRateControlState, GetIncomingRate, Reset

```bash
# Verify no pion imports (standalone)
grep -c "pion" pkg/bwe/bandwidth_estimator.go || echo "No pion imports - correct"
```
Should show 0 or "No pion imports"
  </verify>
  <done>BandwidthEstimator exists with OnPacket and GetEstimate methods, no Pion dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create BandwidthEstimator unit tests</name>
  <files>pkg/bwe/bandwidth_estimator_test.go</files>
  <action>
Create `pkg/bwe/bandwidth_estimator_test.go` with comprehensive tests.

Test cases:

1. **TestBandwidthEstimator_InitialEstimate** - Returns initial bitrate on first call
   ```go
   e := NewBandwidthEstimator(DefaultBandwidthEstimatorConfig(), clock)
   assert.Equal(t, int64(300_000), e.GetEstimate())
   ```

2. **TestBandwidthEstimator_NormalTraffic** - Stable traffic maintains/increases estimate
   - Feed packets at constant rate with no delay variation
   - Verify estimate increases (multiplicative increase)

3. **TestBandwidthEstimator_Congestion** - Congestion decreases estimate
   - Feed packets with increasing delay variation to trigger overuse
   - Verify estimate decreases to 0.85 * incoming rate

4. **TestBandwidthEstimator_TracksSSRCs** - Multiple SSRCs tracked
   - Feed packets from different SSRCs
   - Verify GetSSRCs() returns all seen SSRCs

5. **TestBandwidthEstimator_GetCongestionState** - Exposes delay detector state
   - Verify state transitions visible via GetCongestionState()

6. **TestBandwidthEstimator_GetRateControlState** - Exposes rate control state
   - Verify state transitions visible via GetRateControlState()

7. **TestBandwidthEstimator_GetIncomingRate** - Exposes measured rate
   - Feed known bytes
   - Verify GetIncomingRate() returns correct measurement

8. **TestBandwidthEstimator_Reset** - Reset clears all state
   - Add packets, reset
   - Verify estimate back to initial, SSRCs cleared

9. **TestBandwidthEstimator_NoPionDependency** - Verify no Pion imports
   - Grep test (already in task 1 verify)

10. **TestBandwidthEstimator_StableNetwork** - Integration test
    - Simulate 10 seconds of stable 1 Mbps traffic
    - Verify estimate converges near 1 Mbps

Use the test patterns from Phase 1 (inline packet generation with synchronized clock).
Use pkg/bwe/internal.MockClock for time control.

```go
// Example stable traffic test pattern
clock := internal.NewMockClock(time.Now())
e := NewBandwidthEstimator(DefaultBandwidthEstimatorConfig(), clock)

// Send 1 Mbps for 5 seconds (125KB/s = 125 bytes/ms)
bytesPerMs := int64(125)
for i := 0; i < 5000; i++ {
    pkt := PacketInfo{
        ArrivalTime: clock.Now(),
        SendTime:    uint32(i * 1000), // Convert ms to abs-send-time units
        Size:        int(bytesPerMs),
        SSRC:        0x12345678,
    }
    e.OnPacket(pkt)
    clock.Advance(time.Millisecond)
}

// Estimate should be around 1 Mbps (with some tolerance)
estimate := e.GetEstimate()
assert.InDelta(t, 1_000_000, estimate, 200_000) // +/- 20%
```
  </action>
  <verify>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run TestBandwidthEstimator
```
All tests pass.
  </verify>
  <done>All BandwidthEstimator unit tests pass, verifying end-to-end estimation pipeline</done>
</task>

</tasks>

<verification>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run TestBandwidthEstimator
```
All tests pass.

```bash
# Verify standalone (no pion imports in core files except remb.go)
grep -l "pion" pkg/bwe/*.go | grep -v remb.go | wc -l
```
Should be 0 (only remb.go imports pion).

```bash
cd /Users/thesyncim/GolandProjects/bwe && go build ./...
```
No compilation errors.
</verification>

<success_criteria>
- BandwidthEstimator.OnPacket() accepts packets and updates estimate
- BandwidthEstimator.GetEstimate() returns current estimate
- No Pion dependencies in bandwidth_estimator.go
- All components wired correctly (delay + rate stats + controller)
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-rate-control-remb/02-05-SUMMARY.md`
</output>
