---
phase: 02-rate-control-remb
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/bwe/remb.go
  - pkg/bwe/remb_test.go
  - go.mod
autonomous: true

must_haves:
  truths:
    - "REMB packets are correctly encoded with PT=206, FMT=15"
    - "Bitrate uses mantissa+exponent format (18-bit mantissa, 6-bit exponent)"
    - "REMB packets include list of affected SSRCs"
    - "Encoded packets can be parsed by pion/rtcp"
  artifacts:
    - path: "pkg/bwe/remb.go"
      provides: "REMB packet builder using pion/rtcp"
      exports: ["BuildREMB", "REMBPacket"]
    - path: "pkg/bwe/remb_test.go"
      provides: "Unit tests for REMB encoding"
      min_lines: 80
    - path: "go.mod"
      provides: "pion/rtcp dependency"
      contains: "github.com/pion/rtcp"
  key_links:
    - from: "pkg/bwe/remb.go"
      to: "github.com/pion/rtcp"
      via: "ReceiverEstimatedMaximumBitrate"
      pattern: "rtcp\\.ReceiverEstimatedMaximumBitrate"
---

<objective>
Implement REMB packet building using pion/rtcp library.

Purpose: Generate spec-compliant REMB RTCP packets (PT=206, FMT=15) with correct mantissa+exponent bitrate encoding. REMB packets are sent to the sender to communicate estimated maximum bitrate.

Output: BuildREMB function that creates properly encoded REMB packets using Pion's battle-tested implementation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-rate-control-remb/02-RESEARCH.md

# Research shows: Use pion/rtcp.ReceiverEstimatedMaximumBitrate
# Do NOT hand-roll mantissa+exponent encoding
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add pion/rtcp dependency</name>
  <files>go.mod</files>
  <action>
Add the pion/rtcp dependency to the project:

```bash
cd /Users/thesyncim/GolandProjects/bwe && go get github.com/pion/rtcp
```

Verify go.mod contains the dependency.

Note: pion/rtcp is the standard Go library for RTCP packet encoding/decoding, used by Pion WebRTC. It correctly implements REMB mantissa+exponent encoding per draft-alvestrand-rmcat-remb-03.
  </action>
  <verify>
```bash
grep "pion/rtcp" /Users/thesyncim/GolandProjects/bwe/go.mod
```
Should show the dependency.
  </verify>
  <done>pion/rtcp dependency added to go.mod</done>
</task>

<task type="auto">
  <name>Task 2: Create REMB packet builder</name>
  <files>pkg/bwe/remb.go</files>
  <action>
Create `pkg/bwe/remb.go` implementing REMB packet building.

```go
package bwe

import (
    "github.com/pion/rtcp"
)

// REMBPacket represents a REMB (Receiver Estimated Maximum Bitrate) packet.
// This is a convenience wrapper around pion/rtcp.ReceiverEstimatedMaximumBitrate.
type REMBPacket struct {
    // SenderSSRC is the SSRC of the sender of this REMB packet (us, the receiver).
    // This is typically set by the transport layer.
    SenderSSRC uint32

    // Bitrate is the estimated maximum bitrate in bits per second.
    Bitrate uint64

    // SSRCs is the list of media source SSRCs this estimate applies to.
    SSRCs []uint32
}

// BuildREMB creates a REMB RTCP packet from the given parameters.
// Returns the marshaled packet bytes ready to send.
//
// Parameters:
//   - senderSSRC: SSRC of this RTCP packet sender (receiver endpoint)
//   - bitrateBps: Estimated maximum bitrate in bits per second
//   - mediaSSRCs: List of media SSRCs this estimate applies to
//
// The bitrate is encoded using REMB's mantissa+exponent format:
//   - 6-bit exponent
//   - 18-bit mantissa
// This encoding is handled by pion/rtcp.
func BuildREMB(senderSSRC uint32, bitrateBps uint64, mediaSSRCs []uint32) ([]byte, error) {
    pkt := &rtcp.ReceiverEstimatedMaximumBitrate{
        SenderSSRC: senderSSRC,
        Bitrate:    float32(bitrateBps),
        SSRCs:      mediaSSRCs,
    }
    return pkt.Marshal()
}

// ParseREMB parses a REMB packet from raw bytes.
// Useful for testing and debugging.
func ParseREMB(data []byte) (*REMBPacket, error) {
    pkt := &rtcp.ReceiverEstimatedMaximumBitrate{}
    if err := pkt.Unmarshal(data); err != nil {
        return nil, err
    }
    return &REMBPacket{
        SenderSSRC: pkt.SenderSSRC,
        Bitrate:    uint64(pkt.Bitrate),
        SSRCs:      pkt.SSRCs,
    }, nil
}

// MarshalREMB marshals a REMBPacket to bytes.
func (p *REMBPacket) Marshal() ([]byte, error) {
    return BuildREMB(p.SenderSSRC, p.Bitrate, p.SSRCs)
}
```

Key design decisions:
- Use pion/rtcp directly (don't hand-roll encoding)
- Expose simple BuildREMB function for common use case
- Provide ParseREMB for round-trip testing
- REMBPacket struct for higher-level API if needed
  </action>
  <verify>
```bash
grep -E "^func|^type" pkg/bwe/remb.go
```
Should show: REMBPacket, BuildREMB, ParseREMB, Marshal
  </verify>
  <done>REMB packet builder exists using pion/rtcp, with BuildREMB and ParseREMB functions</done>
</task>

<task type="auto">
  <name>Task 3: Create REMB unit tests</name>
  <files>pkg/bwe/remb_test.go</files>
  <action>
Create `pkg/bwe/remb_test.go` with comprehensive tests.

Test cases:

1. **TestBuildREMB_BasicEncoding** - Build and parse round-trip
   ```go
   data, err := BuildREMB(0x12345678, 1_000_000, []uint32{0xAABBCCDD})
   assert.NoError(t, err)
   parsed, err := ParseREMB(data)
   assert.NoError(t, err)
   assert.Equal(t, uint32(0x12345678), parsed.SenderSSRC)
   assert.Equal(t, uint64(1_000_000), parsed.Bitrate) // 1 Mbps
   assert.Equal(t, []uint32{0xAABBCCDD}, parsed.SSRCs)
   ```

2. **TestBuildREMB_MultipleSSRCs** - Multiple media SSRCs
   - Build with 3 SSRCs
   - Verify all SSRCs present in parsed packet

3. **TestBuildREMB_HighBitrate** - High bitrate encoding (>1 Gbps)
   - Tests mantissa+exponent encoding for large values
   - Build with 2_000_000_000 (2 Gbps)
   - Verify round-trip (may have small loss due to encoding precision)

4. **TestBuildREMB_LowBitrate** - Low bitrate encoding
   - Build with 10_000 (10 kbps)
   - Verify round-trip

5. **TestBuildREMB_ZeroBitrate** - Edge case: zero bitrate
   - Should encode and parse successfully

6. **TestBuildREMB_EmptySSRCs** - No SSRCs (edge case)
   - Should work but unusual

7. **TestREMBPacket_Marshal** - Test REMBPacket.Marshal() method

8. **TestBuildREMB_PacketFormat** - Verify RTCP header format
   - First byte should indicate PSFB (PT=206)
   - Check packet contains "REMB" identifier at correct offset

Use testify/assert for assertions.
  </action>
  <verify>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run TestBuildREMB && go test -v ./pkg/bwe/... -run TestREMBPacket
```
All tests pass.
  </verify>
  <done>All REMB unit tests pass, verifying correct encoding/decoding round-trip for various bitrates and SSRC counts</done>
</task>

</tasks>

<verification>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run "TestBuildREMB|TestREMBPacket"
```
All tests pass.

```bash
cd /Users/thesyncim/GolandProjects/bwe && go build ./...
```
No compilation errors, pion/rtcp dependency resolved.
</verification>

<success_criteria>
- pion/rtcp dependency added
- BuildREMB produces valid REMB packets
- Round-trip encoding/decoding preserves bitrate (within precision limits)
- Multiple SSRCs supported
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-rate-control-remb/02-03-SUMMARY.md`
</output>
