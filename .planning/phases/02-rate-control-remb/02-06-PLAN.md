---
phase: 02-rate-control-remb
plan: 06
type: execute
wave: 4
depends_on: ["02-04", "02-05"]
files_modified:
  - pkg/bwe/bandwidth_estimator.go
  - pkg/bwe/bandwidth_estimator_test.go
autonomous: true

must_haves:
  truths:
    - "Multiple concurrent SSRCs are supported with aggregated bandwidth estimation"
    - "All incoming packets contribute to single rate measurement"
    - "REMB packets include list of all affected SSRCs"
    - "Estimator integrates with REMB scheduler for packet timing"
    - "Full integration test demonstrates end-to-end estimation"
  artifacts:
    - path: "pkg/bwe/bandwidth_estimator.go"
      provides: "Multi-SSRC support and REMB integration"
      exports: ["MaybeBuildREMB", "SetREMBScheduler"]
    - path: "pkg/bwe/bandwidth_estimator_test.go"
      provides: "Integration tests for multi-SSRC and REMB"
      min_lines: 250
  key_links:
    - from: "pkg/bwe/bandwidth_estimator.go"
      to: "pkg/bwe/remb_scheduler.go"
      via: "REMBScheduler for timing"
      pattern: "REMBScheduler"
    - from: "pkg/bwe/bandwidth_estimator.go"
      to: "pkg/bwe/remb.go"
      via: "REMB packet building"
      pattern: "BuildREMB"
---

<objective>
Add multi-SSRC support and REMB integration to complete the Phase 2 API.

Purpose: Enable bandwidth estimation across multiple concurrent media streams (audio + video) with a single aggregated estimate. Integrate REMB scheduler for complete end-to-end functionality.

Output: Enhanced BandwidthEstimator with multi-SSRC aggregation and MaybeBuildREMB for REMB packet generation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-rate-control-remb/02-RESEARCH.md

# Plan 04 output (REMB scheduler)
@pkg/bwe/remb_scheduler.go

# Plan 05 output (BandwidthEstimator)
@pkg/bwe/bandwidth_estimator.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add REMB integration to BandwidthEstimator</name>
  <files>pkg/bwe/bandwidth_estimator.go</files>
  <action>
Enhance `pkg/bwe/bandwidth_estimator.go` with REMB scheduler integration.

Add to BandwidthEstimator struct:
```go
type BandwidthEstimator struct {
    // ... existing fields ...

    // REMB scheduling (optional, set via SetREMBScheduler)
    rembScheduler *REMBScheduler
}
```

Add new methods:
```go
// SetREMBScheduler attaches a REMB scheduler to the estimator.
// Once attached, MaybeBuildREMB can be used to generate REMB packets.
func (e *BandwidthEstimator) SetREMBScheduler(scheduler *REMBScheduler) {
    e.rembScheduler = scheduler
}

// MaybeBuildREMB checks if a REMB packet should be sent and builds it.
// Returns (packet, true, nil) if REMB should be sent.
// Returns (nil, false, nil) if no REMB needed now.
// Returns (nil, false, error) if scheduler not set or encoding fails.
//
// This should be called after OnPacket() or periodically.
//
// Multi-SSRC: The REMB packet includes ALL SSRCs seen by this estimator,
// as receiver-side estimation produces ONE estimate for the entire session.
func (e *BandwidthEstimator) MaybeBuildREMB(now time.Time) ([]byte, bool, error) {
    if e.rembScheduler == nil {
        return nil, false, nil // No scheduler, no REMB
    }

    ssrcs := e.GetSSRCs()
    if len(ssrcs) == 0 {
        return nil, false, nil // No SSRCs seen yet
    }

    return e.rembScheduler.MaybeSendREMB(e.estimate, ssrcs, now)
}
```

Also update OnPacket to optionally track time for REMB:
```go
// Add optional field to track last packet time for REMB scheduling
lastPacketTime time.Time

// In OnPacket, after processing:
e.lastPacketTime = pkt.ArrivalTime
```

The key multi-SSRC behavior (already implemented in Plan 05):
- ALL packets from ALL SSRCs contribute to single rateStats
- ALL packets from ALL SSRCs go through single delayEstimator
- ALL packets from ALL SSRCs feed single rateController
- ONE estimate for the entire session (not per-SSRC)
- REMB includes list of ALL seen SSRCs

This matches receiver-side estimation semantics where the receiver estimates the total available bandwidth on the path, not per-stream.
  </action>
  <verify>
```bash
grep -E "^func.*MaybeBuildREMB|^func.*SetREMBScheduler" pkg/bwe/bandwidth_estimator.go
```
Should show both methods.
  </verify>
  <done>BandwidthEstimator has SetREMBScheduler and MaybeBuildREMB methods</done>
</task>

<task type="auto">
  <name>Task 2: Add multi-SSRC and integration tests</name>
  <files>pkg/bwe/bandwidth_estimator_test.go</files>
  <action>
Add integration tests to `pkg/bwe/bandwidth_estimator_test.go`.

New test cases:

1. **TestBandwidthEstimator_MultiSSRC_Aggregation** - Multiple SSRCs feed single estimate
   ```go
   // Feed packets from SSRC 1 (video) and SSRC 2 (audio)
   // Verify:
   // - GetSSRCs() returns both
   // - GetIncomingRate() is sum of both streams
   // - Single estimate is produced
   ```

2. **TestBandwidthEstimator_MultiSSRC_CongestionAffectsAll**
   - Feed stable traffic from SSRC 1
   - Introduce congestion via SSRC 2 packets
   - Verify estimate decreases (affects all)

3. **TestBandwidthEstimator_REMBIntegration_Basic**
   - Attach REMBScheduler
   - Feed packets for 2 seconds
   - Verify MaybeBuildREMB returns packet at 1s interval

4. **TestBandwidthEstimator_REMBIntegration_ImmediateDecrease**
   - Attach REMBScheduler
   - Feed normal traffic, then induce congestion
   - Verify REMB sent immediately on significant decrease

5. **TestBandwidthEstimator_REMBIntegration_IncludesAllSSRCs**
   - Feed packets from multiple SSRCs
   - Build REMB
   - Parse REMB and verify all SSRCs present

6. **TestBandwidthEstimator_NoSchedulerNoREMB**
   - Without SetREMBScheduler, MaybeBuildREMB returns false

7. **TestBandwidthEstimator_FullPipeline_StableNetwork**
   - Integration test: 30 seconds of stable 2 Mbps traffic
   - 2 SSRCs (video + audio)
   - Verify:
     - Estimate converges to ~2 Mbps
     - REMB sent ~30 times (1 per second)
     - All SSRCs in REMB

8. **TestBandwidthEstimator_FullPipeline_CongestionEvent**
   - Integration test: stable -> congestion -> recovery
   - 5s stable at 2 Mbps
   - 2s congestion (increasing delay)
   - 5s recovery
   - Verify:
     - Estimate decreases during congestion
     - REMB sent immediately on decrease
     - Estimate recovers after congestion clears

Example multi-SSRC test:
```go
func TestBandwidthEstimator_MultiSSRC_Aggregation(t *testing.T) {
    clock := internal.NewMockClock(time.Now())
    e := NewBandwidthEstimator(DefaultBandwidthEstimatorConfig(), clock)

    // Video SSRC: 1 Mbps (125 bytes/ms)
    videoSSRC := uint32(0x11111111)
    // Audio SSRC: 50 kbps (~6 bytes/ms)
    audioSSRC := uint32(0x22222222)

    // Feed interleaved packets for 2 seconds
    for i := 0; i < 2000; i++ {
        // Video packet every ms
        e.OnPacket(PacketInfo{
            ArrivalTime: clock.Now(),
            SendTime:    uint32(i * 1000),
            Size:        125,
            SSRC:        videoSSRC,
        })

        // Audio packet every 20ms
        if i%20 == 0 {
            e.OnPacket(PacketInfo{
                ArrivalTime: clock.Now(),
                SendTime:    uint32(i * 1000),
                Size:        120, // ~50kbps audio
                SSRC:        audioSSRC,
            })
        }

        clock.Advance(time.Millisecond)
    }

    // Verify both SSRCs tracked
    ssrcs := e.GetSSRCs()
    assert.Len(t, ssrcs, 2)
    assert.Contains(t, ssrcs, videoSSRC)
    assert.Contains(t, ssrcs, audioSSRC)

    // Verify aggregated rate (~1.05 Mbps)
    rate, ok := e.GetIncomingRate()
    assert.True(t, ok)
    assert.InDelta(t, 1_050_000, rate, 100_000)
}
```
  </action>
  <verify>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run "TestBandwidthEstimator_Multi|TestBandwidthEstimator_REMB|TestBandwidthEstimator_Full"
```
All tests pass.
  </verify>
  <done>Multi-SSRC and REMB integration tests pass, demonstrating complete Phase 2 functionality</done>
</task>

<task type="auto">
  <name>Task 3: Create Phase 2 integration verification test</name>
  <files>pkg/bwe/bandwidth_estimator_test.go</files>
  <action>
Add a comprehensive end-to-end verification test that demonstrates all Phase 2 requirements are met.

```go
// TestPhase2_RequirementsVerification is a comprehensive test that verifies
// all Phase 2 requirements are met:
// RATE-01: AIMD rate controller (3-state FSM)
// RATE-02: Multiplicative decrease (0.85x)
// RATE-03: Sliding window incoming bitrate measurement
// RATE-04: Configurable AIMD parameters
// REMB-01: Spec-compliant REMB packets
// REMB-02: Mantissa+exponent bitrate encoding
// REMB-03: Configurable REMB send interval
// REMB-04: Immediate REMB on significant decrease
// CORE-01: Standalone Estimator API (no Pion deps)
// CORE-02: OnPacket() with arrival time, send time, size, SSRC
// CORE-03: GetEstimate() returning bps
// CORE-04: Multiple concurrent SSRCs with aggregated estimation
func TestPhase2_RequirementsVerification(t *testing.T) {
    // ... comprehensive test exercising all requirements ...
}
```

This test should:
1. Create BandwidthEstimator with custom config (RATE-04)
2. Feed multi-SSRC traffic (CORE-04)
3. Verify OnPacket/GetEstimate API (CORE-02, CORE-03)
4. Verify no pion imports (CORE-01) - static check
5. Induce congestion, verify decrease (RATE-01, RATE-02)
6. Verify rate measurement works (RATE-03)
7. Attach REMBScheduler, verify REMB sent (REMB-01, REMB-03)
8. Verify REMB encoding (REMB-02) - parse and check
9. Verify immediate REMB on decrease (REMB-04)

This serves as a final verification that Phase 2 is complete.
  </action>
  <verify>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run TestPhase2_RequirementsVerification
```
Test passes.
  </verify>
  <done>Phase 2 requirements verification test passes, confirming all requirements met</done>
</task>

</tasks>

<verification>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/...
```
All tests pass.

```bash
cd /Users/thesyncim/GolandProjects/bwe && go build ./...
```
No compilation errors.

Phase 2 success criteria verification:
1. AIMD rate controller transitions correctly - verified by TestRateController_*
2. Bandwidth estimates respond to network conditions - verified by TestBandwidthEstimator_*
3. REMB packets correctly encoded - verified by TestBuildREMB_*
4. Standalone Estimator API works - verified by TestBandwidthEstimator_* (no Pion in core)
5. Multiple SSRCs supported - verified by TestBandwidthEstimator_MultiSSRC_*
</verification>

<success_criteria>
- Multi-SSRC aggregation: all packets contribute to single estimate
- REMB integration: MaybeBuildREMB produces valid packets at correct times
- All Phase 2 requirements verified by tests
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/02-rate-control-remb/02-06-SUMMARY.md`
</output>
