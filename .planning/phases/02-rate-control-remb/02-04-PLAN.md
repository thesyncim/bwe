---
phase: 02-rate-control-remb
plan: 04
type: execute
wave: 3
depends_on: ["02-02", "02-03"]
files_modified:
  - pkg/bwe/remb_scheduler.go
  - pkg/bwe/remb_scheduler_test.go
autonomous: true

must_haves:
  truths:
    - "REMB packets are sent at configurable interval (default 1Hz)"
    - "REMB is sent immediately on significant bandwidth decrease (>=3%)"
    - "Scheduler tracks last sent value to detect significant changes"
    - "Scheduler integrates with REMB builder for packet generation"
  artifacts:
    - path: "pkg/bwe/remb_scheduler.go"
      provides: "REMB timing and immediate decrease logic"
      exports: ["REMBSchedulerConfig", "REMBScheduler", "MaybeSendREMB"]
    - path: "pkg/bwe/remb_scheduler_test.go"
      provides: "Unit tests for REMB scheduling"
      min_lines: 120
  key_links:
    - from: "pkg/bwe/remb_scheduler.go"
      to: "pkg/bwe/remb.go"
      via: "BuildREMB for packet creation"
      pattern: "BuildREMB"
---

<objective>
Implement REMB scheduling with configurable interval and immediate decrease trigger.

Purpose: Control when REMB packets are sent - regularly at 1Hz for updates, and immediately when bandwidth decreases significantly (>=3%) to ensure sender reacts quickly to congestion.

Output: REMBScheduler that decides when to send REMB and builds packets using the REMB builder from Plan 03.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-rate-control-remb/02-RESEARCH.md

# Plan 03 output (REMB builder)
@pkg/bwe/remb.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create REMB scheduler implementation</name>
  <files>pkg/bwe/remb_scheduler.go</files>
  <action>
Create `pkg/bwe/remb_scheduler.go` implementing REMB timing logic.

```go
package bwe

import (
    "time"
)

// REMBSchedulerConfig configures REMB packet scheduling.
type REMBSchedulerConfig struct {
    // Interval is the regular REMB send interval (default: 1 second).
    Interval time.Duration

    // DecreaseThreshold is the minimum relative decrease to trigger immediate REMB.
    // Default: 0.03 (3% decrease triggers immediate send).
    DecreaseThreshold float64

    // SenderSSRC is the SSRC to use in REMB packets (receiver's SSRC).
    SenderSSRC uint32
}

// DefaultREMBSchedulerConfig returns default scheduler configuration.
func DefaultREMBSchedulerConfig() REMBSchedulerConfig {
    return REMBSchedulerConfig{
        Interval:          time.Second,
        DecreaseThreshold: 0.03, // 3%
        SenderSSRC:        0,    // Will be set by transport
    }
}

// REMBScheduler manages REMB packet timing.
// It sends REMB at regular intervals and immediately on significant decreases.
type REMBScheduler struct {
    config    REMBSchedulerConfig
    lastSent  time.Time
    lastValue int64
}

// NewREMBScheduler creates a new REMB scheduler.
func NewREMBScheduler(config REMBSchedulerConfig) *REMBScheduler {
    return &REMBScheduler{
        config: config,
    }
}

// ShouldSendREMB determines if a REMB packet should be sent now.
// Returns true if either:
//   - Regular interval has elapsed since last send
//   - Estimate decreased by >= DecreaseThreshold (e.g., 3%)
//
// Parameters:
//   - estimate: Current bandwidth estimate in bits per second
//   - now: Current time
func (s *REMBScheduler) ShouldSendREMB(estimate int64, now time.Time) bool {
    // Check for immediate decrease trigger
    if s.lastValue > 0 {
        decrease := float64(s.lastValue-estimate) / float64(s.lastValue)
        if decrease >= s.config.DecreaseThreshold {
            return true
        }
    }

    // Check for regular interval
    if s.lastSent.IsZero() || now.Sub(s.lastSent) >= s.config.Interval {
        return true
    }

    return false
}

// BuildAndRecordREMB creates a REMB packet and records the send.
// Call this after ShouldSendREMB returns true.
//
// Parameters:
//   - estimate: Bandwidth estimate in bits per second
//   - ssrcs: Media SSRCs the estimate applies to
//   - now: Current time
//
// Returns the marshaled REMB packet bytes.
func (s *REMBScheduler) BuildAndRecordREMB(estimate int64, ssrcs []uint32, now time.Time) ([]byte, error) {
    data, err := BuildREMB(s.config.SenderSSRC, uint64(estimate), ssrcs)
    if err != nil {
        return nil, err
    }

    s.lastSent = now
    s.lastValue = estimate
    return data, nil
}

// MaybeSendREMB combines ShouldSendREMB and BuildAndRecordREMB.
// Returns (packet, true) if REMB should be sent, (nil, false) otherwise.
//
// This is the primary API for the scheduler.
func (s *REMBScheduler) MaybeSendREMB(estimate int64, ssrcs []uint32, now time.Time) ([]byte, bool, error) {
    if !s.ShouldSendREMB(estimate, now) {
        return nil, false, nil
    }

    data, err := s.BuildAndRecordREMB(estimate, ssrcs, now)
    if err != nil {
        return nil, false, err
    }
    return data, true, nil
}

// LastSentValue returns the last estimate value that was sent in a REMB.
// Returns 0 if no REMB has been sent yet.
func (s *REMBScheduler) LastSentValue() int64 {
    return s.lastValue
}

// LastSentTime returns when the last REMB was sent.
// Returns zero time if no REMB has been sent yet.
func (s *REMBScheduler) LastSentTime() time.Time {
    return s.lastSent
}

// Reset clears scheduler state (last sent time and value).
func (s *REMBScheduler) Reset() {
    s.lastSent = time.Time{}
    s.lastValue = 0
}
```

Key behaviors:
- First call always sends (lastSent is zero)
- Regular interval: 1 second default
- Immediate send on >=3% decrease
- Tracks lastValue for decrease detection
  </action>
  <verify>
```bash
grep -E "^func|^type" pkg/bwe/remb_scheduler.go
```
Should show: REMBSchedulerConfig, REMBScheduler, NewREMBScheduler, ShouldSendREMB, BuildAndRecordREMB, MaybeSendREMB, LastSentValue, LastSentTime, Reset
  </verify>
  <done>REMBScheduler exists with interval-based and immediate-decrease REMB timing</done>
</task>

<task type="auto">
  <name>Task 2: Create REMB scheduler unit tests</name>
  <files>pkg/bwe/remb_scheduler_test.go</files>
  <action>
Create `pkg/bwe/remb_scheduler_test.go` with comprehensive tests.

Test cases:

1. **TestREMBScheduler_FirstCallAlwaysSends** - First MaybeSendREMB returns true
   ```go
   s := NewREMBScheduler(DefaultREMBSchedulerConfig())
   _, sent, _ := s.MaybeSendREMB(1_000_000, []uint32{0x1234}, t0)
   assert.True(t, sent, "first call should send")
   ```

2. **TestREMBScheduler_RegularInterval** - Sends at 1 second interval
   - Send at t=0
   - No send at t=500ms (too soon)
   - Send at t=1s (interval elapsed)
   - No send at t=1.5s
   - Send at t=2s

3. **TestREMBScheduler_ImmediateDecrease** - Sends on >=3% decrease
   - Send at t=0 with estimate=1_000_000
   - Send immediately at t=100ms with estimate=960_000 (4% decrease)
   - Even though interval not elapsed

4. **TestREMBScheduler_SmallDecreaseNoImmediateSend** - <3% doesn't trigger
   - Send at t=0 with estimate=1_000_000
   - No send at t=100ms with estimate=980_000 (2% decrease)
   - Send at t=1s (regular interval)

5. **TestREMBScheduler_IncreaseNoImmediateSend** - Increases wait for interval
   - Send at t=0 with estimate=1_000_000
   - No send at t=100ms with estimate=1_100_000 (increase)
   - Send at t=1s (regular interval)

6. **TestREMBScheduler_ConfigurableThreshold** - Custom decrease threshold
   - Configure with 0.05 (5%) threshold
   - 4% decrease should NOT trigger immediate
   - 6% decrease SHOULD trigger immediate

7. **TestREMBScheduler_ConfigurableInterval** - Custom interval
   - Configure with 500ms interval
   - Verify sends at 500ms, not waiting for 1s

8. **TestREMBScheduler_REMBPacketContent** - Verify returned packet is valid
   - Call MaybeSendREMB
   - Parse returned bytes with ParseREMB
   - Verify bitrate and SSRCs match input

9. **TestREMBScheduler_LastSentTracking** - LastSentValue and LastSentTime
   - Verify they update after each send
   - Verify they don't update when not sending

10. **TestREMBScheduler_Reset** - Reset clears state

Use testify/assert. Use time.Time for explicit time control (no real clocks).
  </action>
  <verify>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run TestREMBScheduler
```
All tests pass.
  </verify>
  <done>All REMBScheduler unit tests pass, verifying interval-based and immediate-decrease triggers</done>
</task>

</tasks>

<verification>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run TestREMBScheduler
```
All tests pass.

```bash
cd /Users/thesyncim/GolandProjects/bwe && go build ./...
```
No compilation errors.
</verification>

<success_criteria>
- REMB sent at regular 1Hz interval (configurable)
- REMB sent immediately on >=3% decrease (configurable threshold)
- Scheduler correctly tracks last sent time and value
- All unit tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-rate-control-remb/02-04-SUMMARY.md`
</output>
