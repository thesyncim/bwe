---
phase: 02-rate-control-remb
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - pkg/bwe/rate_controller.go
  - pkg/bwe/rate_controller_test.go
autonomous: true

must_haves:
  truths:
    - "Rate controller transitions between Increase/Decrease/Hold states based on congestion signals"
    - "Multiplicative decrease applies 0.85x to measured incoming rate (not current estimate)"
    - "Hold state prevents direct transition from Decrease to Increase"
    - "Estimate is bounded by 1.5x measured incoming rate"
    - "AIMD parameters (beta, min/max bitrate) are configurable"
  artifacts:
    - path: "pkg/bwe/rate_controller.go"
      provides: "AIMD rate controller state machine"
      exports: ["RateControllerConfig", "RateController", "RateControlState", "RateHold", "RateIncrease", "RateDecrease"]
    - path: "pkg/bwe/rate_controller_test.go"
      provides: "Unit tests for rate controller"
      min_lines: 150
  key_links:
    - from: "pkg/bwe/rate_controller.go"
      to: "pkg/bwe/types.go"
      via: "BandwidthUsage signal input"
      pattern: "BwOverusing|BwNormal|BwUnderusing"
---

<objective>
Implement the AIMD (Additive Increase Multiplicative Decrease) rate controller state machine.

Purpose: Convert congestion signals from DelayEstimator into bandwidth estimates. This is the core rate control algorithm from GCC spec Section 6.

Output: RateController that manages Increase/Decrease/Hold states and produces bandwidth estimates in bits per second.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-rate-control-remb/02-RESEARCH.md

# Phase 1 types
@pkg/bwe/types.go

# Plan 01 output (rate measurement)
# Will reference rate_stats.go pattern for incoming rate
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AIMD rate controller implementation</name>
  <files>pkg/bwe/rate_controller.go</files>
  <action>
Create `pkg/bwe/rate_controller.go` implementing the AIMD state machine.

Types and constants:
```go
// RateControlState represents the AIMD state machine state.
type RateControlState int

const (
    RateHold RateControlState = iota
    RateIncrease
    RateDecrease
)

func (s RateControlState) String() string // "Hold", "Increase", "Decrease"

// RateControllerConfig configures the AIMD rate controller.
type RateControllerConfig struct {
    MinBitrate     int64   // Minimum allowed bitrate (default: 10 kbps)
    MaxBitrate     int64   // Maximum allowed bitrate (default: 30 Mbps)
    InitialBitrate int64   // Starting bitrate (default: 300 kbps)
    Beta           float64 // Multiplicative decrease factor (default: 0.85)
}

func DefaultRateControllerConfig() RateControllerConfig
```

State transition table (from GCC spec Section 6):
```
Signal     | Hold     | Increase | Decrease
-----------+----------+----------+----------
Overusing  | Decrease | Decrease | (stay)
Normal     | Increase | (stay)   | Hold
Underusing | (stay)   | Hold     | Hold
```

Core methods:
```go
// RateController implements AIMD rate control.
type RateController struct {
    config      RateControllerConfig
    state       RateControlState
    currentRate int64
    lastUpdate  time.Time
}

// NewRateController creates a new rate controller.
func NewRateController(config RateControllerConfig) *RateController

// Update processes a congestion signal and incoming rate measurement.
// Returns the new bandwidth estimate in bits per second.
//
// CRITICAL: incomingRate is the measured incoming bitrate from RateStats.
// Multiplicative decrease uses incomingRate, NOT currentRate.
func (c *RateController) Update(signal BandwidthUsage, incomingRate int64, now time.Time) int64

// State returns the current rate control state.
func (c *RateController) State() RateControlState

// Estimate returns the current bandwidth estimate without updating.
func (c *RateController) Estimate() int64

// Reset resets the controller to initial state.
func (c *RateController) Reset()
```

Update() implementation:
1. Transition state based on signal (use state table above)
2. Apply rate adjustment based on NEW state:
   - RateDecrease: `newRate = beta * incomingRate` (CRITICAL: use incomingRate)
   - RateIncrease: `newRate = 1.08^elapsed * currentRate` (multiplicative increase)
   - RateHold: no change
3. Clamp to [MinBitrate, MaxBitrate]
4. Enforce ratio constraint: `estimate <= 1.5 * incomingRate` (prevent divergence)
5. Update lastUpdate timestamp
6. Return new estimate

For multiplicative increase (RateIncrease state):
```go
elapsed := now.Sub(c.lastUpdate).Seconds()
eta := math.Pow(1.08, math.Min(elapsed, 1.0))
newRate := int64(eta * float64(c.currentRate))
```

Default config values:
- MinBitrate: 10_000 (10 kbps)
- MaxBitrate: 30_000_000 (30 Mbps)
- InitialBitrate: 300_000 (300 kbps)
- Beta: 0.85
  </action>
  <verify>
```bash
grep -E "^func|^type|^const" pkg/bwe/rate_controller.go
```
Should show: RateControlState, RateHold, RateIncrease, RateDecrease, RateControllerConfig, RateController, NewRateController, Update, State, Estimate, Reset
  </verify>
  <done>RateController exists with correct state machine transitions and AIMD rate adjustment logic</done>
</task>

<task type="auto">
  <name>Task 2: Create comprehensive unit tests for RateController</name>
  <files>pkg/bwe/rate_controller_test.go</files>
  <action>
Create `pkg/bwe/rate_controller_test.go` with comprehensive tests.

Test cases:

1. **TestRateController_InitialState** - Starts in Hold state with initial bitrate

2. **TestRateController_StateTransitions** - Table-driven test for all transitions:
   ```go
   tests := []struct{
       startState RateControlState
       signal     BandwidthUsage
       endState   RateControlState
   }{
       {RateHold, BwOverusing, RateDecrease},
       {RateHold, BwNormal, RateIncrease},
       {RateHold, BwUnderusing, RateHold},
       {RateIncrease, BwOverusing, RateDecrease},
       {RateIncrease, BwNormal, RateIncrease},
       {RateIncrease, BwUnderusing, RateHold},
       {RateDecrease, BwOverusing, RateDecrease},
       {RateDecrease, BwNormal, RateHold},
       {RateDecrease, BwUnderusing, RateHold},
   }
   ```

3. **TestRateController_MultiplicativeDecrease** - Verifies 0.85 * incomingRate
   - Set incomingRate = 1_000_000
   - Send Overusing signal
   - Verify estimate = 850_000 (not 0.85 * previous estimate)

4. **TestRateController_DecreasesFromIncomingNotEstimate** - CRITICAL test
   - Start with estimate = 2_000_000
   - incomingRate = 1_000_000 (sender reduced)
   - Send Overusing
   - Verify estimate = 850_000 (0.85 * 1M, NOT 0.85 * 2M)

5. **TestRateController_MultiplicativeIncrease** - Verifies 1.08^elapsed growth
   - In Increase state, 1 second elapsed
   - Verify newRate = 1.08 * oldRate

6. **TestRateController_HoldNoChange** - Verify Hold state doesn't change rate

7. **TestRateController_BoundsEnforced** - MinBitrate and MaxBitrate respected
   - Decrease cannot go below MinBitrate
   - Increase cannot exceed MaxBitrate

8. **TestRateController_RatioConstraint** - estimate <= 1.5 * incomingRate
   - Set high estimate, low incomingRate
   - Verify clamped to 1.5 * incomingRate

9. **TestRateController_NoDirectDecreaseToIncrease** - Must go through Hold
   - From Decrease, Normal signal goes to Hold (not Increase)

10. **TestRateController_Reset** - Reset returns to initial state

Use testify/assert. Table-driven where appropriate.
  </action>
  <verify>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run TestRateController
```
All tests pass.
  </verify>
  <done>All RateController unit tests pass, including critical test that decrease uses incoming rate not estimate</done>
</task>

</tasks>

<verification>
```bash
cd /Users/thesyncim/GolandProjects/bwe && go test -v ./pkg/bwe/... -run TestRateController
```
All tests pass.

```bash
cd /Users/thesyncim/GolandProjects/bwe && go build ./...
```
No compilation errors.
</verification>

<success_criteria>
- State transitions match GCC spec table exactly
- Multiplicative decrease uses measured incoming rate (0.85 * incomingRate)
- Estimate bounded by min/max bitrate AND 1.5 * incomingRate
- All 10+ test cases pass
</success_criteria>

<output>
After completion, create `.planning/phases/02-rate-control-remb/02-02-SUMMARY.md`
</output>
