---
phase: 04-optimization-validation
plan: 04
type: execute
wave: 2
depends_on: []
files_modified:
  - cmd/chrome-interop/main.go
  - cmd/chrome-interop/README.md
autonomous: false

must_haves:
  truths:
    - "REMB packets are generated and sent to Chrome"
    - "Chrome acknowledges REMB in webrtc-internals"
    - "Bandwidth adaptation is visible in sender behavior"
  artifacts:
    - path: "cmd/chrome-interop/main.go"
      provides: "Chrome interop test server"
      exports: ["main"]
    - path: "cmd/chrome-interop/README.md"
      provides: "Instructions for running Chrome interop test"
      contains: "webrtc-internals"
  key_links:
    - from: "main.go"
      to: "BWEInterceptor"
      via: "Pion PeerConnection with interceptor"
      pattern: "NewBWEInterceptorFactory"
---

<objective>
Create Chrome interoperability test harness for VALID-02 verification.

Purpose: Verify REMB packets are accepted by Chrome and visible in chrome://webrtc-internals. This proves end-to-end interoperability with the target browser.

Output: Interactive test server that connects to Chrome and generates REMB, with instructions for manual verification.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-optimization-validation/04-RESEARCH.md

@pkg/bwe/interceptor/interceptor.go
@pkg/bwe/interceptor/factory.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Chrome interop test server</name>
  <files>cmd/chrome-interop/main.go</files>
  <action>
Create a Pion WebRTC server for Chrome interop testing:

1. Create `cmd/chrome-interop/` directory

2. Implement main.go with:
   - HTTP server on :8080 serving a simple HTML page
   - WebSocket signaling for offer/answer exchange
   - Pion PeerConnection with BWEInterceptorFactory
   - Receive video track from Chrome (Chrome sends, we receive)
   - Log REMB packets being sent
   - Log current bandwidth estimate

3. HTML page (embedded or served):
   - getUserMedia() to capture fake or real video
   - Create RTCPeerConnection
   - Add video track
   - Connect to Go server via WebSocket
   - Display connection status

4. Key implementation details:
   - Use `--use-fake-device-for-media-stream` Chrome flag (documented in README)
   - REMB interval: 1 second (default)
   - Log format: `REMB sent: estimate=%d bps, ssrcs=%v`
   - Enable abs-send-time extension in SDP

5. Server should print helpful messages:
   ```
   Chrome Interop Test Server
   ==========================
   1. Open chrome://webrtc-internals in Chrome
   2. Open http://localhost:8080 in another tab
   3. Click "Start Call"
   4. Check webrtc-internals for "remb" in inbound-rtp stats

   Server ready on :8080
   ```

Based on Pion examples pattern (offer-answer-server).
  </action>
  <verify>
Build: `go build ./cmd/chrome-interop/...`
Expected: Binary builds without errors
  </verify>
  <done>Chrome interop test server implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create documentation and test instructions</name>
  <files>cmd/chrome-interop/README.md</files>
  <action>
Create comprehensive documentation for Chrome interop testing:

1. Overview section:
   - Purpose: Verify VALID-02 (REMB accepted by Chrome)
   - What it tests: End-to-end REMB generation and browser acceptance

2. Prerequisites:
   - Chrome browser (any recent version)
   - Go 1.21+
   - No additional dependencies

3. Quick Start:
   ```bash
   # Build and run
   go run ./cmd/chrome-interop

   # Or with binary
   go build -o chrome-interop ./cmd/chrome-interop
   ./chrome-interop
   ```

4. Testing Steps (numbered):
   1. Open `chrome://webrtc-internals` in Chrome (IMPORTANT: do this FIRST)
   2. Open `http://localhost:8080` in another Chrome tab
   3. Click "Start Call" button
   4. Wait for connection (status shows "Connected")
   5. In webrtc-internals, find the PeerConnection
   6. Look for "remb" in the inbound-rtp stats section
   7. Observe bandwidth estimates in server logs

5. Expected Results:
   - Server logs show: `REMB sent: estimate=XXXXXX bps`
   - webrtc-internals shows "remb" entries
   - Video quality may visibly adapt (lower quality during simulated congestion)

6. Troubleshooting:
   - "No remb visible": Ensure webrtc-internals opened BEFORE the call
   - "Connection failed": Check firewall, ensure :8080 is available
   - "No video": Use `--use-fake-device-for-media-stream` flag

7. Chrome Launch Flags (for testing without camera):
   ```bash
   # macOS
   /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome \
     --use-fake-ui-for-media-stream \
     --use-fake-device-for-media-stream

   # Linux
   google-chrome \
     --use-fake-ui-for-media-stream \
     --use-fake-device-for-media-stream
   ```

8. VALID-02 Pass Criteria:
   - [ ] Connection established successfully
   - [ ] Server logs show REMB packets being sent
   - [ ] chrome://webrtc-internals shows "remb" stats
   - [ ] No REMB-related errors in console
  </action>
  <verify>
Check file exists: `cat cmd/chrome-interop/README.md | head -20`
Expected: Shows documentation header
  </verify>
  <done>Chrome interop documentation complete</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Chrome interop test server that sends REMB packets to Chrome browser</what-built>
  <how-to-verify>
VALID-02 Verification Steps:

1. Start the server:
   ```bash
   go run ./cmd/chrome-interop
   ```

2. Open Chrome with fake media (optional but recommended):
   ```bash
   # macOS
   /Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome \
     --use-fake-ui-for-media-stream \
     --use-fake-device-for-media-stream
   ```

3. Open chrome://webrtc-internals FIRST (before starting call)

4. Open http://localhost:8080 in another tab

5. Click "Start Call" and wait for connection

6. In webrtc-internals, verify:
   - [ ] PeerConnection appears in the list
   - [ ] Click on the connection to expand details
   - [ ] Find "inbound-rtp" section
   - [ ] Look for "remb" or "receiverEstimatedMaxBitrate" entries
   - [ ] Values should be > 0 and change over time

7. In server logs, verify:
   - [ ] "REMB sent" messages appear
   - [ ] Estimates are reasonable (hundreds of kbps to Mbps)

Expected: REMB visible in webrtc-internals, server logs show REMB being sent.
  </how-to-verify>
  <resume-signal>Type "VALID-02 verified" if Chrome accepts REMB, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
VALID-02 Requirement Check:
1. Server builds: `go build ./cmd/chrome-interop/...`
2. Server runs and accepts connections
3. Chrome webrtc-internals shows REMB stats
4. Server logs confirm REMB packets sent

Human verification required for browser interaction.
</verification>

<success_criteria>
- [ ] cmd/chrome-interop/main.go builds and runs
- [ ] cmd/chrome-interop/README.md provides clear instructions
- [ ] Server successfully connects to Chrome
- [ ] REMB packets visible in chrome://webrtc-internals
- [ ] Human verification confirms VALID-02 requirement met
</success_criteria>

<output>
After completion, create `.planning/phases/04-optimization-validation/04-04-SUMMARY.md`
</output>
