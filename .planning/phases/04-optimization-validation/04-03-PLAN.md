---
phase: 04-optimization-validation
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - pkg/bwe/tcp_fairness_test.go
autonomous: true

must_haves:
  truths:
    - "BWE reduces estimate when competing traffic causes congestion"
    - "BWE does not starve (maintains >10% of fair share)"
    - "BWE recovers when competition ends"
  artifacts:
    - path: "pkg/bwe/tcp_fairness_test.go"
      provides: "VALID-03 TCP fairness simulation test"
      exports: ["TestTCPFairness_ThreePhase", "simulateCongestion"]
  key_links:
    - from: "tcp_fairness_test.go"
      to: "BandwidthEstimator"
      via: "Three-phase congestion simulation"
      pattern: "simulateCongestion"
---

<objective>
Create TCP fairness simulation test for VALID-03 requirement.

Purpose: Verify the estimator coexists fairly with TCP traffic - it backs off during congestion but doesn't starve, and recovers when competition ends. This tests the adaptive threshold (K_u/K_d coefficients) behavior.

Output: Three-phase TCP fairness test that verifies proper congestion response.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-optimization-validation/04-RESEARCH.md

@pkg/bwe/bandwidth_estimator.go
@pkg/bwe/rate_controller.go
@pkg/bwe/overuse.go
@pkg/bwe/internal/clock.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TCP fairness simulation helpers</name>
  <files>pkg/bwe/tcp_fairness_test.go</files>
  <action>
Create helper functions for TCP fairness testing:

1. Create `simulateCongestion` function:
   ```go
   // simulateCongestion simulates network traffic with configurable congestion.
   // When congested=true, packets experience increasing delay (simulating queue building from TCP competition).
   // Returns the final bandwidth estimate after the simulation period.
   func simulateCongestion(
       estimator *BandwidthEstimator,
       clock *internal.MockClock,
       duration time.Duration,
       availableBandwidth int64,
       congested bool,
   ) int64
   ```

   Implementation:
   - Generate packets at 20ms intervals (50 pps)
   - Packet size calculated from availableBandwidth / 50 pps
   - If congested:
     - Add 0.3ms delay increase per packet (simulates queue building)
     - After 100 packets, delay stabilizes (queue full)
   - If not congested:
     - Constant delay (stable network)
   - Return final estimate

2. Create `generateCongestionPackets` helper:
   - Generates packet stream with configurable delay pattern
   - Uses testutil-style packet generation

3. Add constants:
   ```go
   const (
       tcpFairnessTestDuration = 30 * time.Second  // Per phase
       fairShareThreshold      = 0.10              // 10% of fair share minimum
       maxShareThreshold       = 0.90              // 90% max during competition
   )
   ```
  </action>
  <verify>
Build: `go build ./pkg/bwe/...`
Expected: No errors
  </verify>
  <done>TCP fairness simulation helpers implemented</done>
</task>

<task type="auto">
  <name>Task 2: Create three-phase TCP fairness test</name>
  <files>pkg/bwe/tcp_fairness_test.go</files>
  <action>
Create the main VALID-03 test following C3Lab methodology:

1. Create `TestTCPFairness_ThreePhase`:
   ```go
   // TestTCPFairness_ThreePhase verifies VALID-03: correct behavior with TCP competition.
   //
   // Methodology from C3Lab WebRTC Testbed:
   // - Phase 1: BWE alone (30s) - should use available bandwidth
   // - Phase 2: BWE + TCP competition (60s) - should reach fair share
   // - Phase 3: BWE alone (30s) - should recover
   //
   // Pass criteria:
   // - Phase 2 estimate > 10% of fair share (no starvation)
   // - Phase 2 estimate < 90% of total bandwidth (appropriate backoff)
   // - Phase 3 estimate > Phase 2 estimate (recovery)
   ```

2. Implementation:
   - Total simulated bandwidth: 2 Mbps
   - Phase 1: No congestion, expect estimate near 2 Mbps
   - Phase 2: Simulate congestion (TCP takes half), expect estimate ~1 Mbps (fair share)
   - Phase 3: Congestion clears, expect recovery toward 2 Mbps

3. Assertions:
   ```go
   // Phase 1: Should utilize most of available bandwidth
   assert.Greater(t, phase1Estimate, int64(1_500_000), "Phase 1: Should use most bandwidth")

   // Phase 2: Fair share (between 10% and 90% of total)
   fairShare := totalBandwidth / 2
   assert.Greater(t, phase2Estimate, fairShare/10, "Phase 2: Should not be starved (<10%)")
   assert.Less(t, phase2Estimate, totalBandwidth*9/10, "Phase 2: Should back off for TCP")

   // Phase 3: Recovery (estimate should increase after congestion ends)
   assert.Greater(t, phase3Estimate, phase2Estimate, "Phase 3: Should recover")
   ```

4. Add logging for debugging:
   - Log estimate at end of each phase
   - Log congestion state transitions
  </action>
  <verify>
Run: `go test -v -run TestTCPFairness ./pkg/bwe/...`
Expected: Test passes with logged phase estimates
  </verify>
  <done>Three-phase TCP fairness test implemented</done>
</task>

<task type="auto">
  <name>Task 3: Add adaptive threshold verification</name>
  <files>pkg/bwe/tcp_fairness_test.go</files>
  <action>
Add tests verifying the adaptive threshold mechanism:

1. Create `TestTCPFairness_AdaptiveThreshold`:
   - Verify K_u (0.01) and K_d (0.00018) coefficients are applied
   - Verify threshold increases faster than it decreases (asymmetry)
   - This asymmetry is critical for TCP fairness

2. Create `TestTCPFairness_SustainedCongestion`:
   - Verify behavior under long-duration congestion (5+ minutes simulated)
   - Ensure no gradual starvation over time
   - Log estimate every simulated minute

3. Create `TestTCPFairness_RapidTransitions`:
   - Rapidly alternate between congested/clear states
   - Verify estimator doesn't oscillate wildly
   - Verify it settles to reasonable values

4. Add test documentation:
   - Reference to GCC spec section on TCP fairness
   - Explain K_u/K_d coefficient rationale
   - Note that real TCP fairness testing requires network impairment tools (tc/netem)
  </action>
  <verify>
Run: `go test -v -run TestTCPFairness ./pkg/bwe/...`
Expected: All TCP fairness tests pass
  </verify>
  <done>Adaptive threshold verification and edge case tests added</done>
</task>

</tasks>

<verification>
VALID-03 Requirement Check:
1. Run TCP fairness tests: `go test -v -run TestTCPFairness ./pkg/bwe/...`
2. Verify Phase 2 shows backoff (estimate < 90% of total)
3. Verify no starvation (estimate > 10% of fair share)
4. Verify recovery in Phase 3

All tests pass: `go test ./pkg/bwe/...`
</verification>

<success_criteria>
- [ ] tcp_fairness_test.go exists with simulation helpers
- [ ] TestTCPFairness_ThreePhase passes with proper backoff/recovery
- [ ] TestTCPFairness_AdaptiveThreshold verifies K_u/K_d asymmetry
- [ ] TestTCPFairness_SustainedCongestion verifies no long-term starvation
- [ ] All assertions verify VALID-03 requirements
- [ ] All existing tests still pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-optimization-validation/04-03-SUMMARY.md`
</output>
