---
phase: 06-test-infrastructure-foundation
plan: 03
type: execute
wave: 2
depends_on: ["06-01", "06-02"]
files_modified:
  - e2e/doc.go
  - e2e/testmain_test.go
  - e2e/browser_test.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "E2E tests are isolated from go test ./... via build tags"
    - "TestChrome_CanConnect passes in headless mode"
    - "Orphaned Chrome processes are cleaned up via TestMain"
    - "Server starts on random port for test isolation"
  artifacts:
    - path: "e2e/doc.go"
      provides: "Package documentation with build tag explanation"
      contains: "//go:build e2e"
    - path: "e2e/testmain_test.go"
      provides: "TestMain with orphaned browser cleanup"
      contains: "cleanupOrphanedBrowsers"
    - path: "e2e/browser_test.go"
      provides: "TestChrome_CanConnect smoke test"
      contains: "TestChrome_CanConnect"
  key_links:
    - from: "e2e/browser_test.go"
      to: "bwe/cmd/chrome-interop/server"
      via: "import and programmatic server start"
      pattern: "server\\.NewServer|server\\.Start"
    - from: "e2e/browser_test.go"
      to: "bwe/pkg/bwe/testutil"
      via: "import BrowserClient"
      pattern: "testutil\\.NewBrowserClient"
---

<objective>
Create e2e/ test directory with build-tagged scaffolding and smoke test

Purpose: Establish isolated E2E test infrastructure with TestChrome_CanConnect verifying browser automation works end-to-end
Output: e2e/ directory with doc.go, testmain_test.go, browser_test.go - all build-tagged to exclude from go test ./...
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-infrastructure-foundation/06-RESEARCH.md

# Prior plan outputs (for imports)
@.planning/phases/06-test-infrastructure-foundation/06-01-SUMMARY.md
@.planning/phases/06-test-infrastructure-foundation/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create e2e package with documentation</name>
  <files>
    e2e/doc.go
  </files>
  <action>
Create `e2e/doc.go` with package documentation:

```go
//go:build e2e

// Package e2e provides end-to-end tests for the BWE implementation.
//
// These tests are isolated from the standard test suite via build tags.
// They require a Chrome browser (auto-downloaded by Rod if not present)
// and are intended for CI pipelines or explicit local testing.
//
// Running E2E tests:
//
//	go test -tags=e2e ./e2e/...
//
// Running all tests except E2E:
//
//	go test ./...
//
// E2E tests use:
//   - Rod for browser automation (Chrome DevTools Protocol)
//   - chrome-interop server for WebRTC signaling
//   - BrowserClient from pkg/bwe/testutil for Chrome helpers
//
// Test isolation:
// Each test starts its own server on a random port and launches
// its own browser instance. Tests can run in parallel.
package e2e
```

The `//go:build e2e` constraint ensures this package is excluded from `go test ./...`.
  </action>
  <verify>
`go build -tags=e2e ./e2e/` compiles
`go test -v ./e2e/ 2>&1 | grep -q "no Go files"` confirms exclusion without tags
  </verify>
  <done>
e2e/doc.go exists with build tag and package documentation
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TestMain with browser cleanup</name>
  <files>
    e2e/testmain_test.go
  </files>
  <action>
Create `e2e/testmain_test.go` with TestMain for global setup/teardown:

```go
//go:build e2e

package e2e

import (
    "os"
    "os/exec"
    "runtime"
    "testing"
)

func TestMain(m *testing.M) {
    // Run all tests
    code := m.Run()

    // Cleanup: Kill any orphaned Chrome processes
    // This is a safety net for test failures/panics where
    // defer browser.Close() didn't run
    cleanupOrphanedBrowsers()

    os.Exit(code)
}

// cleanupOrphanedBrowsers attempts to kill Chrome processes that may have
// been left behind by failed tests. This is best-effort cleanup.
//
// In normal operation, each test's defer browser.Close() handles cleanup.
// This function catches edge cases like panics or os.Exit during tests.
func cleanupOrphanedBrowsers() {
    switch runtime.GOOS {
    case "darwin", "linux":
        // pkill returns non-zero if no processes matched, ignore error
        // Target both chromium (Rod downloads) and chrome (system install)
        _ = exec.Command("pkill", "-f", "chromium|chrome").Run()
    case "windows":
        // taskkill returns non-zero if process not found, ignore error
        _ = exec.Command("taskkill", "/F", "/IM", "chrome.exe").Run()
        _ = exec.Command("taskkill", "/F", "/IM", "chromium.exe").Run()
    }
}
```

Critical patterns from research:
- TestMain runs after ALL tests complete, catching panics
- pkill -f matches command line arguments (catches Rod's chromium)
- Errors are ignored because "no matching processes" is not an error for us
  </action>
  <verify>
`go build -tags=e2e ./e2e/` compiles
  </verify>
  <done>
e2e/testmain_test.go exists with TestMain and cleanupOrphanedBrowsers
  </done>
</task>

<task type="auto">
  <name>Task 3: Create smoke test TestChrome_CanConnect</name>
  <files>
    e2e/browser_test.go
  </files>
  <action>
Create `e2e/browser_test.go` with the smoke test:

```go
//go:build e2e

package e2e

import (
    "context"
    "strings"
    "testing"
    "time"

    "bwe/cmd/chrome-interop/server"
    "bwe/pkg/bwe/testutil"
)

// TestChrome_CanConnect verifies the complete E2E test infrastructure:
// 1. Server can start programmatically on random port
// 2. Browser can launch in headless mode with WebRTC flags
// 3. Browser can navigate to server
// 4. Page loads successfully
// 5. Cleanup works (no orphaned processes)
//
// This is a smoke test - it validates infrastructure, not BWE behavior.
func TestChrome_CanConnect(t *testing.T) {
    // Start server on random port
    cfg := server.DefaultConfig()
    srv, err := server.NewServer(cfg)
    if err != nil {
        t.Fatalf("failed to create server: %v", err)
    }

    addr, err := srv.Start()
    if err != nil {
        t.Fatalf("failed to start server: %v", err)
    }
    defer func() {
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
        defer cancel()
        if err := srv.Shutdown(ctx); err != nil {
            t.Errorf("server shutdown error: %v", err)
        }
    }()

    t.Logf("Server started on %s", addr)

    // Launch browser
    browserCfg := testutil.DefaultBrowserConfig()
    client, err := testutil.NewBrowserClient(browserCfg)
    if err != nil {
        t.Fatalf("failed to create browser: %v", err)
    }
    defer func() {
        if err := client.Close(); err != nil {
            t.Errorf("browser close error: %v", err)
        }
    }()

    // Navigate to server
    url := "http://" + addr
    t.Logf("Navigating to %s", url)

    page, err := client.Navigate(url)
    if err != nil {
        t.Fatalf("failed to navigate: %v", err)
    }

    // Wait for page to stabilize
    if err := client.WaitStable(); err != nil {
        t.Fatalf("page not stable: %v", err)
    }

    // Verify page loaded by checking title
    title := page.MustElement("title").MustText()
    if !strings.Contains(title, "BWE") {
        t.Errorf("unexpected page title: got %q, want contains 'BWE'", title)
    }

    // Verify WebRTC is available
    result, err := client.Eval(`typeof RTCPeerConnection !== 'undefined'`)
    if err != nil {
        t.Fatalf("failed to check RTCPeerConnection: %v", err)
    }
    if result != true {
        t.Error("RTCPeerConnection not available in browser")
    }

    t.Log("Smoke test passed: server, browser, and WebRTC all working")
}
```

Test structure:
1. Start server on :0 (random port) - uses 06-01 server package
2. Launch browser with WebRTC flags - uses 06-02 BrowserClient
3. Navigate to server URL
4. Verify page loads (check title)
5. Verify WebRTC available (RTCPeerConnection exists)
6. Cleanup via defers

The test validates all Phase 6 success criteria:
- E2E directory with build tags (this file has //go:build e2e)
- BrowserClient works (NewBrowserClient, Navigate, Eval)
- Server package works (NewServer, Start, Shutdown)
- Cleanup robust (double defer pattern for server and browser)
  </action>
  <verify>
1. `go test -tags=e2e -v ./e2e/ -run TestChrome_CanConnect` passes
2. No orphaned Chrome processes after test: `pgrep -f chromium` returns empty
  </verify>
  <done>
TestChrome_CanConnect passes in headless mode. Test verifies server start, browser launch, navigation, and WebRTC availability.
  </done>
</task>

</tasks>

<verification>
1. Build tag isolation: `go test ./e2e/` shows "no Go files" (excluded)
2. E2E tests run: `go test -tags=e2e -v ./e2e/` shows TestChrome_CanConnect PASS
3. No orphaned processes: After test, `pgrep -f chromium` returns empty
4. Random port works: Test logs show different port each run
</verification>

<success_criteria>
1. `e2e/` directory exists with doc.go, testmain_test.go, browser_test.go
2. All files have `//go:build e2e` constraint
3. `go test ./e2e/` is a no-op (build tag exclusion)
4. `go test -tags=e2e ./e2e/` runs TestChrome_CanConnect
5. TestChrome_CanConnect passes: server starts, browser navigates, page loads, WebRTC available
6. No orphaned Chrome processes after test execution (verified via TestMain cleanup)
</success_criteria>

<output>
After completion, create `.planning/phases/06-test-infrastructure-foundation/06-03-SUMMARY.md`
</output>
