---
phase: 06-test-infrastructure-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/chrome-interop/server/server.go
  - cmd/chrome-interop/server/handler.go
  - cmd/chrome-interop/server/html.go
  - cmd/chrome-interop/main.go
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tests can import and instantiate the chrome-interop server without running main()"
    - "Server can start on random port (:0) and return actual address"
    - "Server can be gracefully shutdown with context"
    - "CLI still works (main.go calls server package)"
  artifacts:
    - path: "cmd/chrome-interop/server/server.go"
      provides: "Server type with NewServer, Start, Shutdown, Addr methods"
      exports: ["Server", "Config", "DefaultConfig", "NewServer"]
    - path: "cmd/chrome-interop/server/handler.go"
      provides: "HTTP handler for /offer endpoint with WebRTC logic"
      exports: ["HandleOffer"]
    - path: "cmd/chrome-interop/server/html.go"
      provides: "HTML page constant for browser UI"
      exports: ["HTMLPage"]
    - path: "cmd/chrome-interop/main.go"
      provides: "Thin CLI wrapper calling server package"
      min_lines: 20
  key_links:
    - from: "cmd/chrome-interop/main.go"
      to: "cmd/chrome-interop/server"
      via: "import and call server.NewServer().Start()"
      pattern: "server\\.NewServer|server\\.Start"
    - from: "cmd/chrome-interop/server/server.go"
      to: "cmd/chrome-interop/server/handler.go"
      via: "mux.HandleFunc routing"
      pattern: "HandleOffer|mux\\.HandleFunc"
---

<objective>
Refactor cmd/chrome-interop/main.go into an importable server package

Purpose: Enable E2E tests to programmatically start/stop the chrome-interop server without running the CLI
Output: cmd/chrome-interop/server/ package with Server type exposing NewServer(), Start(), Shutdown(), Addr() methods
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-infrastructure-foundation/06-RESEARCH.md

# Existing code to refactor
@cmd/chrome-interop/main.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server package with Server type</name>
  <files>
    cmd/chrome-interop/server/server.go
  </files>
  <action>
Create `cmd/chrome-interop/server/server.go` with:

1. Package `server` (importable from `bwe/cmd/chrome-interop/server`)

2. Config struct:
```go
type Config struct {
    Addr         string        // e.g., ":8080" or ":0" for random port
    ReadTimeout  time.Duration
    WriteTimeout time.Duration
}
```

3. DefaultConfig() returning sensible defaults (":0" for tests, 30s timeouts)

4. Server struct:
```go
type Server struct {
    httpServer *http.Server
    listener   net.Listener
    addr       string
    mu         sync.Mutex
    running    bool
}
```

5. Methods:
- `NewServer(cfg Config) (*Server, error)` - Creates server with mux, registers handlers
- `Start() (string, error)` - Starts listening, returns actual address (useful when port is 0)
- `Shutdown(ctx context.Context) error` - Graceful shutdown
- `Addr() string` - Returns listening address

Key implementation details from research:
- Use net.Listen("tcp", addr) then httpServer.Serve(ln) pattern
- Store listener to get actual address after binding
- Use sync.Mutex to guard running state
- go httpServer.Serve() in Start() (non-blocking)
  </action>
  <verify>
`go build ./cmd/chrome-interop/server/` compiles without errors
  </verify>
  <done>
Server type exists with NewServer, Start, Shutdown, Addr methods. Package compiles.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extract handlers and HTML to separate files</name>
  <files>
    cmd/chrome-interop/server/handler.go
    cmd/chrome-interop/server/html.go
  </files>
  <action>
Create `cmd/chrome-interop/server/handler.go`:
1. Move handleOffer function from main.go
2. Rename to HandleOffer (exported) for testing
3. Keep all WebRTC logic: MediaEngine, interceptor registry, BWE factory, NACK, peer connection creation
4. Keep REMBLogger and loggingInterceptorFactory types (can be unexported)
5. Handler signature: `func HandleOffer(w http.ResponseWriter, r *http.Request)`

Create `cmd/chrome-interop/server/html.go`:
1. Move htmlPage constant from main.go
2. Rename to HTMLPage (exported) for potential customization
3. Export as: `const HTMLPage = \`...\``

Update server.go to use these:
- Import and route: `mux.HandleFunc("/", handleHTML)` where handleHTML serves HTMLPage
- `mux.HandleFunc("/offer", HandleOffer)`
  </action>
  <verify>
`go build ./cmd/chrome-interop/server/` compiles without errors
  </verify>
  <done>
HandleOffer handler extracted and exported. HTMLPage constant extracted and exported.
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor main.go to use server package</name>
  <files>
    cmd/chrome-interop/main.go
  </files>
  <action>
Rewrite `cmd/chrome-interop/main.go` as thin CLI wrapper:

1. Import `bwe/cmd/chrome-interop/server`

2. main() function should:
   - Print welcome message (keep existing format)
   - Create server with Config{Addr: ":8080"} (hardcoded for CLI use)
   - Call srv.Start()
   - Block forever (select{} or signal handling)

3. Remove all code that moved to server package:
   - htmlPage constant
   - handleOffer function
   - REMBLogger type
   - loggingInterceptorFactory type
   - http.HandleFunc calls
   - http.ListenAndServe call

4. Keep it minimal (~30-40 lines)

Example structure:
```go
package main

import (
    "fmt"
    "log"
    "bwe/cmd/chrome-interop/server"
)

func main() {
    fmt.Println(`Chrome Interop Test Server...`)

    cfg := server.Config{Addr: ":8080"}
    srv, err := server.NewServer(cfg)
    if err != nil {
        log.Fatalf("Failed to create server: %v", err)
    }

    addr, err := srv.Start()
    if err != nil {
        log.Fatalf("Failed to start server: %v", err)
    }

    fmt.Printf("Server ready on %s\n", addr)
    select {} // Block forever
}
```
  </action>
  <verify>
1. `go build ./cmd/chrome-interop/` compiles
2. `./cmd/chrome-interop/chrome-interop` starts and prints welcome message
3. `curl http://localhost:8080/` returns HTML page
  </verify>
  <done>
main.go is thin wrapper (~30-40 lines). CLI functionality preserved. Server starts on :8080.
  </done>
</task>

</tasks>

<verification>
1. Package compiles: `go build ./cmd/chrome-interop/...`
2. CLI works: Run binary, verify welcome message and HTTP responses
3. Server can be imported: `go build -n` in a test file importing the server package
4. Unit test: Create a simple test that starts/stops server programmatically:
   ```go
   srv, _ := server.NewServer(server.DefaultConfig())
   addr, _ := srv.Start()
   // addr should be like "127.0.0.1:XXXXX" (random port)
   srv.Shutdown(context.Background())
   ```
</verification>

<success_criteria>
1. `cmd/chrome-interop/server/` package exists with Server, Config, NewServer, Start, Shutdown exports
2. `cmd/chrome-interop/main.go` is a thin wrapper (<50 lines) that imports and uses server package
3. CLI still works: starts on :8080, serves HTML, handles /offer
4. Server.Start() with ":0" returns actual bound address
5. Server.Shutdown() cleanly stops the server
</success_criteria>

<output>
After completion, create `.planning/phases/06-test-infrastructure-foundation/06-01-SUMMARY.md`
</output>
