---
phase: 07-network-simulation
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - pkg/bwe/testutil/vnet_peer.go
  - pkg/bwe/testutil/vnet_peer_test.go
autonomous: true

must_haves:
  truths:
    - "User can create WebRTC PeerConnections that communicate over virtual network"
    - "PeerConnections use vnet.Net via SettingEngine.SetNet()"
    - "ICE candidates work within virtual network address space"
    - "Helper functions simplify vnet PeerConnection creation"
  artifacts:
    - path: "pkg/bwe/testutil/vnet_peer.go"
      provides: "VNet PeerConnection helpers"
      exports: ["VNetPeerConfig", "NewVNetPeerConnection"]
  key_links:
    - from: "pkg/bwe/testutil/vnet_peer.go"
      to: "pion/webrtc/v4"
      via: "import webrtc, use SettingEngine.SetNet"
      pattern: "webrtc\\.SettingEngine"
    - from: "pkg/bwe/testutil/vnet_peer.go"
      to: "pkg/bwe/testutil/network.go"
      via: "accepts *vnet.Net from VNetSimulator"
      pattern: "\\*vnet\\.Net"
---

<objective>
Create helper functions to integrate Pion WebRTC PeerConnection with vnet virtual networks.

Purpose: Enable E2E tests to run full WebRTC connections over simulated network conditions. This bridges VNetSimulator (Plan 01) with PeerConnection, allowing BWE behavior testing under latency/loss/bandwidth constraints.

Output: `pkg/bwe/testutil/vnet_peer.go` with VNetPeerConfig and NewVNetPeerConnection helper.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-network-simulation/07-RESEARCH.md

Prior plan context (VNetSimulator API):
@.planning/phases/07-network-simulation/07-01-PLAN.md

Existing PeerConnection patterns:
@pkg/bwe/interceptor/integration_test.go (existing Pion integration patterns)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create vnet_peer.go with VNetPeerConfig and constructor</name>
  <files>pkg/bwe/testutil/vnet_peer.go</files>
  <action>
Create `pkg/bwe/testutil/vnet_peer.go` with PeerConnection-over-vnet helper:

```go
// vnet_peer.go provides helpers for creating WebRTC PeerConnections over virtual networks.
package testutil

import (
    "fmt"
    "time"

    "github.com/pion/interceptor"
    "github.com/pion/transport/v4/vnet"
    "github.com/pion/webrtc/v4"
)

// VNetPeerConfig configures a PeerConnection for use with vnet.
type VNetPeerConfig struct {
    // Net is the virtual network to bind to (required)
    Net *vnet.Net

    // InterceptorRegistry allows adding interceptors like BWE (optional)
    InterceptorRegistry *interceptor.Registry

    // ICEDisconnectedTimeout is how long to wait before transitioning to disconnected
    // Default: 10 seconds (shorter than production for faster test feedback)
    ICEDisconnectedTimeout time.Duration

    // ICEFailedTimeout is how long to wait before transitioning to failed
    // Default: 30 seconds
    ICEFailedTimeout time.Duration
}

// DefaultVNetPeerConfig returns sensible defaults for testing.
func DefaultVNetPeerConfig(net *vnet.Net) VNetPeerConfig {
    return VNetPeerConfig{
        Net:                    net,
        ICEDisconnectedTimeout: 10 * time.Second,
        ICEFailedTimeout:       30 * time.Second,
    }
}

// NewVNetPeerConnection creates a PeerConnection bound to a virtual network.
// The PeerConnection will only use ICE candidates within the vnet address space.
//
// Usage:
//
//     sim, _ := testutil.NewVNetSimulator(testutil.ProfileConstantLatency100ms)
//     defer sim.Stop()
//     net1, _ := sim.AddNet("192.168.0.1")
//     sim.Start()
//
//     cfg := testutil.DefaultVNetPeerConfig(net1)
//     pc, _ := testutil.NewVNetPeerConnection(cfg)
//     defer pc.Close()
func NewVNetPeerConnection(cfg VNetPeerConfig) (*webrtc.PeerConnection, error) {
    if cfg.Net == nil {
        return nil, fmt.Errorf("VNetPeerConfig.Net is required")
    }

    // Configure SettingEngine to use virtual network
    se := webrtc.SettingEngine{}
    se.SetNet(cfg.Net)

    // Set ICE timeouts for faster test feedback
    if cfg.ICEDisconnectedTimeout > 0 || cfg.ICEFailedTimeout > 0 {
        disconnected := cfg.ICEDisconnectedTimeout
        if disconnected == 0 {
            disconnected = 10 * time.Second
        }
        failed := cfg.ICEFailedTimeout
        if failed == 0 {
            failed = 30 * time.Second
        }
        se.SetICETimeouts(disconnected, failed, 2*time.Second)
    }

    // Build API options
    var opts []func(*webrtc.API)
    opts = append(opts, webrtc.WithSettingEngine(se))

    // Add interceptor registry if provided
    if cfg.InterceptorRegistry != nil {
        opts = append(opts, webrtc.WithInterceptorRegistry(cfg.InterceptorRegistry))
    }

    // Create API
    api := webrtc.NewAPI(opts...)

    // Create PeerConnection with minimal config (no STUN/TURN needed in vnet)
    pcConfig := webrtc.Configuration{
        // No ICE servers needed - vnet uses host candidates only
    }

    return api.NewPeerConnection(pcConfig)
}
```
  </action>
  <verify>
```bash
go build ./pkg/bwe/testutil/
```
Package compiles with VNetPeerConfig and NewVNetPeerConnection.
  </verify>
  <done>VNetPeerConfig and NewVNetPeerConnection exported for creating PeerConnections over vnet.</done>
</task>

<task type="auto">
  <name>Task 2: Add signaling helper functions</name>
  <files>pkg/bwe/testutil/vnet_peer.go</files>
  <action>
Add signaling helpers to `pkg/bwe/testutil/vnet_peer.go` for connecting two PeerConnections:

```go
// ConnectVNetPeers performs SDP exchange between two PeerConnections.
// It creates an offer from pc1, sets it as remote on pc2, creates an answer,
// and completes the exchange. Both PeerConnections should be newly created.
//
// This is a simplified signaling flow suitable for testing.
func ConnectVNetPeers(pc1, pc2 *webrtc.PeerConnection) error {
    // Gather ICE candidates before exchanging SDP
    // This ensures candidates are included in the SDP

    // Create offer from pc1
    offer, err := pc1.CreateOffer(nil)
    if err != nil {
        return fmt.Errorf("CreateOffer failed: %w", err)
    }

    // Set local description on pc1
    if err := pc1.SetLocalDescription(offer); err != nil {
        return fmt.Errorf("pc1 SetLocalDescription failed: %w", err)
    }

    // Wait for ICE gathering to complete on pc1
    gatherComplete := webrtc.GatheringCompletePromise(pc1)
    <-gatherComplete

    // Set remote description on pc2
    if err := pc2.SetRemoteDescription(*pc1.LocalDescription()); err != nil {
        return fmt.Errorf("pc2 SetRemoteDescription failed: %w", err)
    }

    // Create answer from pc2
    answer, err := pc2.CreateAnswer(nil)
    if err != nil {
        return fmt.Errorf("CreateAnswer failed: %w", err)
    }

    // Set local description on pc2
    if err := pc2.SetLocalDescription(answer); err != nil {
        return fmt.Errorf("pc2 SetLocalDescription failed: %w", err)
    }

    // Wait for ICE gathering to complete on pc2
    gatherComplete2 := webrtc.GatheringCompletePromise(pc2)
    <-gatherComplete2

    // Set remote description on pc1
    if err := pc1.SetRemoteDescription(*pc2.LocalDescription()); err != nil {
        return fmt.Errorf("pc1 SetRemoteDescription failed: %w", err)
    }

    return nil
}

// WaitForPeerConnectionState waits for the PeerConnection to reach the target state.
// Returns error if timeout expires before reaching the state.
func WaitForPeerConnectionState(pc *webrtc.PeerConnection, target webrtc.PeerConnectionState, timeout time.Duration) error {
    if pc.ConnectionState() == target {
        return nil
    }

    done := make(chan struct{})
    pc.OnConnectionStateChange(func(state webrtc.PeerConnectionState) {
        if state == target {
            close(done)
        }
    })

    select {
    case <-done:
        return nil
    case <-time.After(timeout):
        return fmt.Errorf("timeout waiting for state %s, current: %s", target, pc.ConnectionState())
    }
}
```
  </action>
  <verify>
```bash
go build ./pkg/bwe/testutil/
go doc ./pkg/bwe/testutil/ | grep -E "(ConnectVNetPeers|WaitForPeerConnectionState)"
```
Functions exported and visible in go doc output.
  </verify>
  <done>ConnectVNetPeers and WaitForPeerConnectionState helpers simplify vnet PeerConnection testing.</done>
</task>

<task type="auto">
  <name>Task 3: Add unit test for vnet PeerConnection helpers</name>
  <files>pkg/bwe/testutil/vnet_peer_test.go</files>
  <action>
Create `pkg/bwe/testutil/vnet_peer_test.go` to verify vnet PeerConnection integration:

```go
package testutil

import (
    "testing"
    "time"

    "github.com/pion/webrtc/v4"
)

func TestNewVNetPeerConnection_RequiresNet(t *testing.T) {
    _, err := NewVNetPeerConnection(VNetPeerConfig{})
    if err == nil {
        t.Error("expected error when Net is nil")
    }
}

func TestNewVNetPeerConnection_WithVNet(t *testing.T) {
    // Create simulator
    sim, err := NewVNetSimulator(NetworkCondition{})
    if err != nil {
        t.Fatalf("NewVNetSimulator failed: %v", err)
    }
    defer sim.Stop()

    // Create virtual network
    net1, err := sim.AddNet("192.168.0.1")
    if err != nil {
        t.Fatalf("AddNet failed: %v", err)
    }

    // Start router
    if err := sim.Start(); err != nil {
        t.Fatalf("Start failed: %v", err)
    }

    // Create PeerConnection
    cfg := DefaultVNetPeerConfig(net1)
    pc, err := NewVNetPeerConnection(cfg)
    if err != nil {
        t.Fatalf("NewVNetPeerConnection failed: %v", err)
    }
    defer pc.Close()

    // Verify PeerConnection was created
    if pc == nil {
        t.Fatal("PeerConnection is nil")
    }

    // Should be in new state
    if pc.ConnectionState() != webrtc.PeerConnectionStateNew {
        t.Errorf("unexpected state: %v", pc.ConnectionState())
    }
}

func TestConnectVNetPeers_DataChannel(t *testing.T) {
    // This test verifies two PeerConnections can connect over vnet

    // Create simulator with no impairment
    sim, err := NewVNetSimulator(NetworkCondition{})
    if err != nil {
        t.Fatalf("NewVNetSimulator failed: %v", err)
    }
    defer sim.Stop()

    // Create two networks
    net1, err := sim.AddNet("192.168.0.1")
    if err != nil {
        t.Fatalf("AddNet net1 failed: %v", err)
    }

    net2, err := sim.AddNet("192.168.0.2")
    if err != nil {
        t.Fatalf("AddNet net2 failed: %v", err)
    }

    // Start router
    if err := sim.Start(); err != nil {
        t.Fatalf("Start failed: %v", err)
    }

    // Create PeerConnections
    pc1, err := NewVNetPeerConnection(DefaultVNetPeerConfig(net1))
    if err != nil {
        t.Fatalf("NewVNetPeerConnection pc1 failed: %v", err)
    }
    defer pc1.Close()

    pc2, err := NewVNetPeerConnection(DefaultVNetPeerConfig(net2))
    if err != nil {
        t.Fatalf("NewVNetPeerConnection pc2 failed: %v", err)
    }
    defer pc2.Close()

    // Create data channel on pc1 (needed to generate SDP with candidates)
    dc1, err := pc1.CreateDataChannel("test", nil)
    if err != nil {
        t.Fatalf("CreateDataChannel failed: %v", err)
    }

    // Track data channel open on pc2
    dc2Opened := make(chan *webrtc.DataChannel)
    pc2.OnDataChannel(func(dc *webrtc.DataChannel) {
        dc.OnOpen(func() {
            dc2Opened <- dc
        })
    })

    // Connect the peers
    if err := ConnectVNetPeers(pc1, pc2); err != nil {
        t.Fatalf("ConnectVNetPeers failed: %v", err)
    }

    // Wait for connection
    if err := WaitForPeerConnectionState(pc1, webrtc.PeerConnectionStateConnected, 10*time.Second); err != nil {
        t.Fatalf("pc1 failed to connect: %v", err)
    }

    if err := WaitForPeerConnectionState(pc2, webrtc.PeerConnectionStateConnected, 10*time.Second); err != nil {
        t.Fatalf("pc2 failed to connect: %v", err)
    }

    // Wait for data channel to open
    select {
    case dc2 := <-dc2Opened:
        t.Logf("Data channel %s opened successfully", dc2.Label())
    case <-time.After(5 * time.Second):
        t.Fatal("data channel did not open within timeout")
    }

    // Send message through data channel
    msgReceived := make(chan string)
    pc2.OnDataChannel(func(dc *webrtc.DataChannel) {
        dc.OnMessage(func(msg webrtc.DataChannelMessage) {
            msgReceived <- string(msg.Data)
        })
    })

    // Wait for dc1 to be open
    dc1.OnOpen(func() {
        dc1.SendText("hello vnet")
    })

    // If dc1 is already open, send now
    if dc1.ReadyState() == webrtc.DataChannelStateOpen {
        dc1.SendText("hello vnet")
    }

    t.Log("VNet PeerConnection data channel test: PASS")
}

func TestConnectVNetPeers_WithLatency(t *testing.T) {
    // Verify connection works with network impairment

    // Create simulator with 50ms latency
    sim, err := NewVNetSimulator(NetworkCondition{
        Latency: 50 * time.Millisecond,
        Seed:    [2]uint64{1, 1},
    })
    if err != nil {
        t.Fatalf("NewVNetSimulator failed: %v", err)
    }
    defer sim.Stop()

    net1, err := sim.AddNet("192.168.0.1")
    if err != nil {
        t.Fatalf("AddNet net1 failed: %v", err)
    }

    net2, err := sim.AddNet("192.168.0.2")
    if err != nil {
        t.Fatalf("AddNet net2 failed: %v", err)
    }

    if err := sim.Start(); err != nil {
        t.Fatalf("Start failed: %v", err)
    }

    pc1, err := NewVNetPeerConnection(DefaultVNetPeerConfig(net1))
    if err != nil {
        t.Fatalf("NewVNetPeerConnection pc1 failed: %v", err)
    }
    defer pc1.Close()

    pc2, err := NewVNetPeerConnection(DefaultVNetPeerConfig(net2))
    if err != nil {
        t.Fatalf("NewVNetPeerConnection pc2 failed: %v", err)
    }
    defer pc2.Close()

    // Need media or data channel for ICE
    _, err = pc1.CreateDataChannel("test", nil)
    if err != nil {
        t.Fatalf("CreateDataChannel failed: %v", err)
    }

    // Connect - may take longer due to latency
    start := time.Now()
    if err := ConnectVNetPeers(pc1, pc2); err != nil {
        t.Fatalf("ConnectVNetPeers failed: %v", err)
    }

    if err := WaitForPeerConnectionState(pc1, webrtc.PeerConnectionStateConnected, 15*time.Second); err != nil {
        t.Fatalf("pc1 failed to connect: %v", err)
    }
    elapsed := time.Since(start)

    t.Logf("VNet PeerConnection with 50ms latency: connected in %v", elapsed)
}
```
  </action>
  <verify>
```bash
go test -v ./pkg/bwe/testutil/ -run "VNetPeer|ConnectVNetPeers"
```
All tests pass, including data channel communication over vnet.
  </verify>
  <done>Unit tests verify vnet PeerConnection creation and connection over virtual networks with latency.</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Package builds:**
```bash
go build ./pkg/bwe/testutil/
```
No errors.

2. **Exports visible:**
```bash
go doc ./pkg/bwe/testutil/ | grep -E "(VNetPeer|ConnectVNet|WaitForPeer)"
```
Shows VNetPeerConfig, NewVNetPeerConnection, ConnectVNetPeers, WaitForPeerConnectionState.

3. **Tests pass:**
```bash
go test -v ./pkg/bwe/testutil/ -run "VNetPeer"
```
All vnet PeerConnection tests pass.

4. **Integration with VNetSimulator:**
```bash
go test -v ./pkg/bwe/testutil/ -run "ConnectVNetPeers_WithLatency"
```
PeerConnections connect over simulated network with latency.
</verification>

<success_criteria>
- VNetPeerConfig exported with Net, InterceptorRegistry, ICE timeout fields
- NewVNetPeerConnection creates PeerConnection bound to vnet.Net via SettingEngine
- ConnectVNetPeers performs complete SDP exchange between two PeerConnections
- WaitForPeerConnectionState provides timeout-based state waiting
- Unit tests verify:
  - Error when Net is nil
  - PeerConnection creation succeeds with vnet
  - Two PeerConnections can connect and exchange data over vnet
  - Connection works with network impairment (latency)
</success_criteria>

<output>
After completion, create `.planning/phases/07-network-simulation/07-03-SUMMARY.md`
</output>
