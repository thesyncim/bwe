---
phase: 01-foundation-core-pipeline
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - pkg/bwe/trendline.go
  - pkg/bwe/trendline_test.go
autonomous: true

must_haves:
  truths:
    - "Trendline estimator uses linear regression over a sliding window of samples"
    - "Smoothed delay is accumulated with exponential smoothing (default 0.9)"
    - "Slope is multiplied by sample count and threshold gain for comparison"
    - "Window size is configurable (default 20 samples)"
  artifacts:
    - path: "pkg/bwe/trendline.go"
      provides: "Trendline estimator as alternative to Kalman filter"
      exports: ["TrendlineEstimator", "NewTrendlineEstimator", "TrendlineConfig"]
    - path: "pkg/bwe/trendline_test.go"
      provides: "Unit tests for trendline estimation"
      min_lines: 60
  key_links:
    - from: "pkg/bwe/trendline.go"
      to: "pkg/bwe/types.go"
      via: "uses time types"
      pattern: "time.Duration"
---

<objective>
Implement the trendline estimator as an alternative delay gradient filter.

Purpose: Modern WebRTC implementations use trendline estimation (linear regression) as the default filter instead of Kalman. This provides an alternative filtering approach that may perform better in some network conditions. Both filters output a comparable "modified trend" value for the overuse detector.

Output: TrendlineEstimator that accumulates delay samples, performs linear regression over a sliding window, and outputs a modified trend value comparable to Kalman filter output.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-pipeline/01-RESEARCH.md
@pkg/bwe/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement trendline estimator with linear regression</name>
  <files>pkg/bwe/trendline.go</files>
  <action>
Create `pkg/bwe/trendline.go`:

1. Define `TrendlineConfig` struct:
```go
type TrendlineConfig struct {
    WindowSize    int     // Number of samples in regression window, default 20
    SmoothingCoef float64 // Exponential smoothing for accumulated delay, default 0.9
    ThresholdGain float64 // Multiplier for slope output, default 4.0
}

func DefaultTrendlineConfig() TrendlineConfig {
    return TrendlineConfig{
        WindowSize:    20,
        SmoothingCoef: 0.9,
        ThresholdGain: 4.0,
    }
}
```

2. Define internal sample type:
```go
type sample struct {
    arrivalTimeMs float64 // Arrival time in ms since estimator start
    smoothedDelay float64 // Accumulated smoothed delay at this point
}
```

3. Define `TrendlineEstimator` struct:
```go
type TrendlineEstimator struct {
    config        TrendlineConfig
    history       []sample  // Sliding window of samples
    smoothedDelay float64   // Running smoothed delay accumulator
    numDeltas     int       // Total number of samples seen
    firstArrival  time.Time // Reference time for arrivalTimeMs calculation
}
```

4. Constructor `NewTrendlineEstimator(config TrendlineConfig)`:
   - Validate WindowSize >= 2, default if invalid
   - Initialize empty history slice with capacity = WindowSize
   - smoothedDelay = 0, numDeltas = 0
   - firstArrival = zero time (set on first sample)

5. Method `(t *TrendlineEstimator) Update(arrivalTime time.Time, delayVariationMs float64) float64`:
```go
// Set reference time on first sample
if t.firstArrival.IsZero() {
    t.firstArrival = arrivalTime
}

// Compute arrival time in ms since start
arrivalMs := float64(arrivalTime.Sub(t.firstArrival).Milliseconds())

// Exponential smoothing of accumulated delay
// smoothedDelay represents the accumulated trend
t.smoothedDelay = t.config.SmoothingCoef*t.smoothedDelay + (1-t.config.SmoothingCoef)*delayVariationMs

// Add sample to history
t.history = append(t.history, sample{arrivalMs, t.smoothedDelay})

// Maintain window size
if len(t.history) > t.config.WindowSize {
    t.history = t.history[1:]
}

t.numDeltas++

// Compute slope via linear regression
slope := t.linearFitSlope()

// Modified trend: min(numDeltas, 60) * slope * gain
// The min(60) caps the multiplier to prevent runaway values
numSamples := float64(t.numDeltas)
if numSamples > 60 {
    numSamples = 60
}

return numSamples * slope * t.config.ThresholdGain
```

6. Method `(t *TrendlineEstimator) linearFitSlope() float64`:
```go
n := len(t.history)
if n < 2 {
    return 0
}

// Least squares: slope = (n*sum(xy) - sum(x)*sum(y)) / (n*sum(x^2) - (sum(x))^2)
var sumX, sumY, sumXX, sumXY float64
for _, s := range t.history {
    sumX += s.arrivalTimeMs
    sumY += s.smoothedDelay
    sumXX += s.arrivalTimeMs * s.arrivalTimeMs
    sumXY += s.arrivalTimeMs * s.smoothedDelay
}

nf := float64(n)
denom := nf*sumXX - sumX*sumX
if denom == 0 {
    return 0
}

return (nf*sumXY - sumX*sumY) / denom
```

7. Method `(t *TrendlineEstimator) Reset()`:
   - Clear history
   - Reset smoothedDelay = 0
   - Reset numDeltas = 0
   - Reset firstArrival to zero time
  </action>
  <verify>
`go build ./pkg/bwe/...` succeeds
  </verify>
  <done>
TrendlineEstimator implements linear regression over sliding window with exponential smoothing and threshold gain multiplier.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for trendline estimator</name>
  <files>pkg/bwe/trendline_test.go</files>
  <action>
Create `pkg/bwe/trendline_test.go`:

1. Test initial state:
   - New estimator with default config
   - First few updates with 0ms delay return ~0 (no trend)

2. Test positive trend detection (queue building):
   - Feed increasing delays: 0, 1, 2, 3, 4, 5... ms over time
   - Output should become increasingly positive
   - Slope should reflect the positive trend

3. Test negative trend detection (queue draining):
   - Feed decreasing delays: 5, 4, 3, 2, 1, 0... ms
   - Output should become increasingly negative

4. Test stable network (no trend):
   - Feed constant 0ms variations
   - Output should stay near 0

5. Test window sliding:
   - Fill window with positive trend samples
   - Then add samples with opposite trend
   - Verify output changes as old samples slide out

6. Test smoothing effect:
   - Feed noisy data with underlying positive trend
   - e.g., 1, -0.5, 2, -0.3, 3, -0.2, 4...
   - Smoothed output should track the trend, not the noise

7. Test threshold gain:
   - Create estimator with different ThresholdGain values
   - Same input should produce proportionally different outputs

8. Test Reset():
   - Fill estimator with samples
   - Call Reset()
   - Verify state is cleared, next sample starts fresh

9. Test arrival time spacing:
   - Samples with larger time gaps should contribute proportionally to slope
   - Two samples 100ms apart with +10ms delay variation = slope ~0.1 ms/ms

Use MockClock or fixed time.Time values for deterministic arrival times.
  </action>
  <verify>
`go test ./pkg/bwe/... -v -run Trendline` passes all tests
  </verify>
  <done>
Tests verify trendline estimator detects positive/negative trends, handles stable networks, slides window correctly, and applies smoothing and threshold gain.
  </done>
</task>

</tasks>

<verification>
1. `go test ./pkg/bwe/... -v` passes all trendline tests
2. Increasing delay inputs produce positive output
3. Decreasing delay inputs produce negative output
4. Stable (zero variation) inputs produce near-zero output
5. Window sliding test shows output changes when old samples removed
</verification>

<success_criteria>
- FILTER-03: Trendline estimator implemented as alternative filter option
- Linear regression slope calculation correct
- Exponential smoothing and threshold gain applied
- Both Kalman (01-03) and Trendline filters available for overuse detector
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-pipeline/01-04-SUMMARY.md`
</output>
