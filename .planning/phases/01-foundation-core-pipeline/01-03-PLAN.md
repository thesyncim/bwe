---
phase: 01-foundation-core-pipeline
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - pkg/bwe/kalman.go
  - pkg/bwe/kalman_test.go
autonomous: true

must_haves:
  truths:
    - "Kalman filter smooths noisy delay measurements into stable gradient estimates"
    - "Initial parameters match IETF draft: q=10^-3, e(0)=0.1"
    - "Outlier filtering caps innovation at 3*sqrt(measurement_variance)"
    - "Measurement noise variance is exponentially smoothed with chi coefficient"
  artifacts:
    - path: "pkg/bwe/kalman.go"
      provides: "Scalar Kalman filter for delay gradient estimation"
      exports: ["KalmanFilter", "NewKalmanFilter", "KalmanConfig"]
    - path: "pkg/bwe/kalman_test.go"
      provides: "Unit tests for Kalman filter behavior"
      min_lines: 60
  key_links:
    - from: "pkg/bwe/kalman.go"
      to: "pkg/bwe/types.go"
      via: "uses time.Duration for measurements"
      pattern: "time.Duration"
---

<objective>
Implement the scalar Kalman filter for delay gradient estimation per IETF draft-ietf-rmcat-gcc.

Purpose: Raw inter-arrival delay measurements are noisy due to network jitter. The Kalman filter produces smoothed delay gradient estimates (m_hat) that track queuing delay trends without oscillating on transient spikes.

Output: KalmanFilter that takes delay variation measurements and produces smoothed delay gradient estimates suitable for the overuse detector.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-pipeline/01-RESEARCH.md
@pkg/bwe/types.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Kalman filter with spec-compliant parameters</name>
  <files>pkg/bwe/kalman.go</files>
  <action>
Create `pkg/bwe/kalman.go`:

1. Define `KalmanConfig` struct for tunable parameters:
```go
type KalmanConfig struct {
    ProcessNoise float64 // q - state noise variance, default 10^-3
    InitialError float64 // e(0) - initial error covariance, default 0.1
    Chi          float64 // exponential smoothing coefficient, default 0.01
}

func DefaultKalmanConfig() KalmanConfig {
    return KalmanConfig{
        ProcessNoise: 0.001,  // q = 10^-3 per spec
        InitialError: 0.1,    // e(0) = 0.1 per spec
        Chi:          0.01,   // recommended range [0.001, 0.1]
    }
}
```

2. Define `KalmanFilter` struct:
```go
type KalmanFilter struct {
    config       KalmanConfig
    estimate     float64 // m_hat(i) - current delay gradient estimate in ms
    errorCov     float64 // e(i) - error covariance
    measureNoise float64 // var_v_hat - measurement noise variance
}
```

3. Constructor `NewKalmanFilter(config KalmanConfig)`:
   - Initialize estimate = 0 (assume no initial delay)
   - Initialize errorCov = config.InitialError
   - Initialize measureNoise = 1.0 (will adapt)

4. Method `(k *KalmanFilter) Update(measurement float64) float64`:
   The measurement is delay variation in milliseconds.

   ```go
   // Innovation (prediction error)
   z := measurement - k.estimate

   // Outlier filtering: cap at 3*sqrt(var_v)
   maxDeviation := 3 * math.Sqrt(k.measureNoise)
   zCapped := z
   if z > maxDeviation {
       zCapped = maxDeviation
   } else if z < -maxDeviation {
       zCapped = -maxDeviation
   }

   // Update measurement noise estimate (exponential averaging)
   k.measureNoise = math.Max(1.0, (1-k.config.Chi)*k.measureNoise + k.config.Chi*zCapped*zCapped)

   // Kalman gain: K = (e + q) / (var_v + e + q)
   gain := (k.errorCov + k.config.ProcessNoise) / (k.measureNoise + k.errorCov + k.config.ProcessNoise)

   // State update: m_hat(i) = m_hat(i-1) + K * z
   k.estimate = k.estimate + z*gain

   // Error covariance update: e(i) = (1 - K) * (e(i-1) + q)
   k.errorCov = (1 - gain) * (k.errorCov + k.config.ProcessNoise)

   return k.estimate
   ```

5. Method `(k *KalmanFilter) Estimate() float64`:
   - Return current estimate (for inspection without update)

6. Method `(k *KalmanFilter) Reset()`:
   - Reset estimate to 0
   - Reset errorCov to config.InitialError
   - Reset measureNoise to 1.0

Key insight: The filter tracks the TREND of delay, not absolute delay. A positive estimate means delay is increasing (queue building). The chi parameter controls how quickly measurement noise variance adapts.
  </action>
  <verify>
`go build ./pkg/bwe/...` succeeds
  </verify>
  <done>
KalmanFilter implements scalar Kalman filter with spec-compliant parameters (q=0.001, e(0)=0.1, chi=0.01), outlier filtering at 3*sigma, and exponential smoothing of measurement noise.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add tests for Kalman filter behavior</name>
  <files>pkg/bwe/kalman_test.go</files>
  <action>
Create `pkg/bwe/kalman_test.go`:

1. Test initial state:
   - New filter with default config
   - Estimate() returns 0
   - First update with 0ms returns ~0 (no change)

2. Test tracking positive trend (queue building):
   - Feed sequence: 1, 2, 3, 4, 5 ms delay variations
   - Estimate should trend positive
   - Should not jump immediately to 5, but smoothly increase

3. Test tracking negative trend (queue draining):
   - Feed sequence: -1, -2, -3, -4, -5 ms delay variations
   - Estimate should trend negative
   - Should smooth the descent

4. Test outlier rejection:
   - Feed small variations: 1, 2, 1, 2 ms
   - Then spike: 100 ms (outlier)
   - Then normal: 2, 1, 2 ms
   - Estimate should not jump to 100, spike should be capped at 3*sqrt(var_v)

5. Test stable network (zero trend):
   - Feed variations oscillating around 0: +1, -1, +0.5, -0.5, 0
   - Estimate should stay near 0

6. Test convergence speed:
   - Feed constant 10ms variations
   - After ~50 updates, estimate should be close to 10
   - Verify it doesn't take forever (chi controls this)

7. Test Reset():
   - Feed values to change state
   - Call Reset()
   - Verify Estimate() returns 0

8. Test custom config:
   - Create filter with higher chi (0.1) for faster adaptation
   - Verify it responds faster to changes

Use table-driven tests where appropriate. Tolerance for float comparisons: 0.1ms.
  </action>
  <verify>
`go test ./pkg/bwe/... -v -run Kalman` passes all tests
  </verify>
  <done>
Tests verify Kalman filter tracks delay trends, rejects outliers, handles stable networks, and converges appropriately.
  </done>
</task>

</tasks>

<verification>
1. `go test ./pkg/bwe/... -v` passes all Kalman tests
2. Filter with increasing inputs (1,2,3,4,5) produces positive estimate
3. Filter with decreasing inputs (-1,-2,-3,-4,-5) produces negative estimate
4. Outlier test: 100ms spike does not make estimate jump to 100
5. Stable network test: estimate stays near 0 for oscillating inputs
</verification>

<success_criteria>
- FILTER-01: Kalman filter for delay gradient estimation implemented
- FILTER-02: Spec-compliant parameters (q=10^-3, e(0)=0.1) used
- Filter produces stable estimates suitable for overuse detection
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-pipeline/01-03-SUMMARY.md`
</output>
