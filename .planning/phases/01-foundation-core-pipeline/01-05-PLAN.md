---
phase: 01-foundation-core-pipeline
plan: 05
type: execute
wave: 3
depends_on: ["01-01", "01-03", "01-04"]
files_modified:
  - pkg/bwe/overuse.go
  - pkg/bwe/overuse_test.go
autonomous: true

must_haves:
  truths:
    - "Detector transitions between Normal/Overusing/Underusing based on filtered delay gradient"
    - "Adaptive threshold uses asymmetric coefficients (K_u=0.01, K_d=0.00018)"
    - "Overuse is only signaled after sustained violation (>=10ms)"
    - "Signal suppression prevents overuse signal when gradient is decreasing"
    - "State change callbacks notify application code"
  artifacts:
    - path: "pkg/bwe/overuse.go"
      provides: "Overuse detector with adaptive threshold"
      exports: ["OveruseDetector", "NewOveruseDetector", "OveruseConfig", "StateChangeCallback"]
    - path: "pkg/bwe/overuse_test.go"
      provides: "Unit tests for overuse detection"
      min_lines: 100
  key_links:
    - from: "pkg/bwe/overuse.go"
      to: "pkg/bwe/types.go"
      via: "uses BandwidthUsage enum"
      pattern: "BwNormal|BwOverusing|BwUnderusing"
    - from: "pkg/bwe/overuse.go"
      to: "pkg/bwe/internal/clock.go"
      via: "uses Clock for timing"
      pattern: "Clock"
---

<objective>
Implement the overuse detector with adaptive threshold and state change callbacks.

Purpose: The overuse detector is the decision-making component that determines network congestion state. It compares filtered delay gradient estimates against an adaptive threshold, requires sustained overuse before signaling, and suppresses signals when the gradient is decreasing. This prevents false positives and TCP starvation.

Output: OveruseDetector that takes filtered delay gradient values (from Kalman or Trendline) and produces BandwidthUsage states with callbacks on state changes.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-pipeline/01-RESEARCH.md
@pkg/bwe/types.go
@pkg/bwe/internal/clock.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement overuse detector with adaptive threshold</name>
  <files>pkg/bwe/overuse.go</files>
  <action>
Create `pkg/bwe/overuse.go`:

1. Define callback type:
```go
// StateChangeCallback is called when bandwidth usage state changes
type StateChangeCallback func(old, new BandwidthUsage)
```

2. Define `OveruseConfig` struct:
```go
type OveruseConfig struct {
    InitialThreshold  float64       // del_var_th initial value, default 12.5 ms
    MinThreshold      float64       // Minimum threshold, default 6.0 ms
    MaxThreshold      float64       // Maximum threshold, default 600.0 ms
    Ku                float64       // Threshold increase rate, default 0.01
    Kd                float64       // Threshold decrease rate, default 0.00018
    OveruseTimeThresh time.Duration // Sustained overuse requirement, default 10ms
}

func DefaultOveruseConfig() OveruseConfig {
    return OveruseConfig{
        InitialThreshold:  12.5,
        MinThreshold:      6.0,
        MaxThreshold:      600.0,
        Ku:                0.01,
        Kd:                0.00018,
        OveruseTimeThresh: 10 * time.Millisecond,
    }
}
```

3. Define `OveruseDetector` struct:
```go
type OveruseDetector struct {
    config          OveruseConfig
    clock           Clock
    threshold       float64       // Current adaptive threshold
    lastUpdateTime  time.Time     // For threshold adaptation timing
    overuseStart    time.Time     // When current overuse period started
    overuseCounter  int           // Consecutive overuse detections
    prevEstimate    float64       // Previous estimate for suppression check
    hypothesis      BandwidthUsage // Current state
    callback        StateChangeCallback
}
```

4. Constructor `NewOveruseDetector(config OveruseConfig, clock Clock)`:
   - If clock is nil, use MonotonicClock{}
   - Initialize threshold = config.InitialThreshold
   - Initialize hypothesis = BwNormal
   - lastUpdateTime = zero (set on first update)

5. Method `(d *OveruseDetector) SetCallback(cb StateChangeCallback)`:
   - Store callback for state change notifications

6. Method `(d *OveruseDetector) updateThreshold(estimate float64, now time.Time)`:
```go
absEstimate := math.Abs(estimate)

// Initialize lastUpdateTime on first call
if d.lastUpdateTime.IsZero() {
    d.lastUpdateTime = now
    return
}

// Time since last update in seconds
deltaT := now.Sub(d.lastUpdateTime).Seconds()
d.lastUpdateTime = now

// Select coefficient: Ku when over threshold, Kd when under
k := d.config.Kd
if absEstimate > d.threshold {
    k = d.config.Ku
}

// Update threshold: del_var_th += deltaT * K * (|m| - del_var_th)
d.threshold += deltaT * k * (absEstimate - d.threshold)

// Clamp to valid range
if d.threshold < d.config.MinThreshold {
    d.threshold = d.config.MinThreshold
}
if d.threshold > d.config.MaxThreshold {
    d.threshold = d.config.MaxThreshold
}
```

7. Method `(d *OveruseDetector) Detect(estimate float64) BandwidthUsage`:
```go
now := d.clock.Now()
d.updateThreshold(estimate, now)

oldHypothesis := d.hypothesis

if estimate > d.threshold {
    // Potential overuse
    if d.hypothesis != BwOverusing {
        // Start tracking overuse period
        d.overuseStart = now
        d.overuseCounter = 0
    }
    d.overuseCounter++

    // Signal suppression: don't signal overuse if gradient is decreasing
    if estimate < d.prevEstimate {
        d.hypothesis = BwNormal
    } else if now.Sub(d.overuseStart) >= d.config.OveruseTimeThresh && d.overuseCounter > 1 {
        // Sustained overuse confirmed
        d.hypothesis = BwOverusing
    }
} else if estimate < -d.threshold {
    // Underuse (negative delay = queue draining fast)
    d.hypothesis = BwUnderusing
} else {
    // Normal operation
    d.hypothesis = BwNormal
}

d.prevEstimate = estimate

// Invoke callback on state change
if d.hypothesis != oldHypothesis && d.callback != nil {
    d.callback(oldHypothesis, d.hypothesis)
}

return d.hypothesis
```

8. Method `(d *OveruseDetector) State() BandwidthUsage`:
   - Return current hypothesis without updating

9. Method `(d *OveruseDetector) Threshold() float64`:
   - Return current threshold value (for debugging/monitoring)

10. Method `(d *OveruseDetector) Reset()`:
    - Reset threshold to config.InitialThreshold
    - Reset hypothesis to BwNormal
    - Clear overuseStart, overuseCounter, prevEstimate
    - lastUpdateTime = zero

CRITICAL: The asymmetric K_u/K_d coefficients are essential for TCP fairness. K_u=0.01 means threshold increases slowly when overuse detected, K_d=0.00018 means threshold decreases faster when estimate is below threshold. This prevents being too aggressive.
  </action>
  <verify>
`go build ./pkg/bwe/...` succeeds
  </verify>
  <done>
OveruseDetector implements adaptive threshold with asymmetric coefficients, sustained overuse requirement, signal suppression, and state change callbacks.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add comprehensive tests for overuse detection</name>
  <files>pkg/bwe/overuse_test.go</files>
  <action>
Create `pkg/bwe/overuse_test.go`:

1. Test initial state:
   - New detector starts in BwNormal
   - Threshold equals InitialThreshold (12.5)

2. Test normal operation:
   - Feed estimates within threshold: 5, -3, 7, -5, 10 ms
   - State remains BwNormal throughout

3. Test overuse detection with sustained requirement:
   - Feed estimates exceeding threshold: 15, 16, 17, 18 ms
   - Advance clock 10ms+ between calls
   - State should transition to BwOverusing after sustained period
   - Verify callback invoked with (BwNormal, BwOverusing)

4. Test signal suppression:
   - Feed increasing estimates: 15, 16, 17 ms (above threshold)
   - Then decreasing: 16, 15, 14 ms (still above threshold but decreasing)
   - Decreasing estimates should suppress overuse signal
   - State should be BwNormal despite being above threshold

5. Test underuse detection:
   - Feed strongly negative estimates: -15, -16, -17 ms
   - State should transition to BwUnderusing
   - Verify callback invoked

6. Test adaptive threshold increase (Ku):
   - Feed estimates exceeding threshold repeatedly
   - Threshold should increase over time
   - Verify threshold > InitialThreshold after many samples

7. Test adaptive threshold decrease (Kd):
   - Start with elevated threshold (from prior overuse)
   - Feed estimates below threshold
   - Threshold should decrease toward estimate level (slowly due to Kd < Ku)

8. Test threshold clamping:
   - Feed very high estimates (1000ms) repeatedly
   - Threshold should not exceed MaxThreshold (600)
   - Feed very low estimates (-1000ms)
   - Threshold should not drop below MinThreshold (6)

9. Test state transition back to normal:
   - Enter BwOverusing state
   - Feed estimates within threshold: 5, 3, -2 ms
   - State should return to BwNormal
   - Verify callback invoked

10. Test callback registration:
    - Register callback, trigger state change
    - Verify callback receives correct old/new states
    - Set callback to nil, trigger change
    - Verify no panic

11. Test Reset():
    - Modify state (enter overuse, change threshold)
    - Call Reset()
    - Verify threshold = InitialThreshold, state = BwNormal

Use MockClock for deterministic timing control.
  </action>
  <verify>
`go test ./pkg/bwe/... -v -run Overuse` passes all tests
  </verify>
  <done>
Tests verify all overuse detector behaviors: state transitions, adaptive threshold, signal suppression, sustained requirement, callbacks, and clamping.
  </done>
</task>

</tasks>

<verification>
1. `go test ./pkg/bwe/... -v` passes all overuse tests
2. Normal estimates (within threshold) keep state BwNormal
3. Sustained overuse (>10ms above threshold, not decreasing) triggers BwOverusing
4. Decreasing estimates above threshold stay BwNormal (suppression)
5. Strongly negative estimates trigger BwUnderusing
6. Callbacks fire on every state transition
</verification>

<success_criteria>
- DETECT-01: 3-state detector (Normal/Overusing/Underusing) implemented
- DETECT-02: Adaptive threshold with K_u=0.01, K_d=0.00018 working
- DETECT-03: Sustained overuse (>=10ms) required before signaling
- DETECT-04: State change callbacks provided to application code
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-pipeline/01-05-SUMMARY.md`
</output>
