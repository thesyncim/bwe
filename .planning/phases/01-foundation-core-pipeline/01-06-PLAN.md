---
phase: 01-foundation-core-pipeline
plan: 06
type: execute
wave: 4
depends_on: ["01-01", "01-02", "01-03", "01-04", "01-05"]
files_modified:
  - pkg/bwe/timestamp.go
  - pkg/bwe/estimator.go
  - pkg/bwe/estimator_test.go
  - pkg/bwe/testutil/traces.go
autonomous: true

must_haves:
  truths:
    - "Abs-capture-time 64-bit parsing works as alternative to abs-send-time"
    - "All components (interarrival, filter, detector) integrate into working pipeline"
    - "Pipeline produces correct congestion signals from synthetic packet traces"
    - "Monotonic time is used consistently with no wall clock leakage"
  artifacts:
    - path: "pkg/bwe/timestamp.go"
      provides: "Extended timestamp parsing including abs-capture-time"
      exports: ["ParseAbsCaptureTime", "AbsCaptureTimeToDuration"]
    - path: "pkg/bwe/estimator.go"
      provides: "Orchestrator connecting all Phase 1 components"
      exports: ["DelayEstimator", "NewDelayEstimator", "DelayEstimatorConfig"]
    - path: "pkg/bwe/estimator_test.go"
      provides: "Integration tests for full pipeline"
      min_lines: 100
    - path: "pkg/bwe/testutil/traces.go"
      provides: "Synthetic packet trace generators for testing"
      exports: ["StableNetworkTrace", "CongestingNetworkTrace", "DrainingNetworkTrace", "WraparoundTrace"]
  key_links:
    - from: "pkg/bwe/estimator.go"
      to: "pkg/bwe/interarrival.go"
      via: "uses InterArrivalCalculator"
      pattern: "InterArrivalCalculator"
    - from: "pkg/bwe/estimator.go"
      to: "pkg/bwe/kalman.go"
      via: "uses KalmanFilter or TrendlineEstimator"
      pattern: "KalmanFilter|TrendlineEstimator"
    - from: "pkg/bwe/estimator.go"
      to: "pkg/bwe/overuse.go"
      via: "uses OveruseDetector"
      pattern: "OveruseDetector"
---

<objective>
Complete Phase 1 with abs-capture-time parsing, full pipeline integration, and comprehensive integration tests.

Purpose: Wire all Phase 1 components into a working delay-based congestion detection pipeline. Add abs-capture-time support (TIME-03). Create test utilities for synthetic packet traces that exercise wraparound, burst grouping, and state transitions. Validate monotonic time usage throughout.

Output: DelayEstimator orchestrator that processes packets and produces BandwidthUsage signals, plus test utilities and integration tests proving the pipeline works end-to-end.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-foundation-core-pipeline/01-RESEARCH.md
@pkg/bwe/types.go
@pkg/bwe/timestamp.go
@pkg/bwe/interarrival.go
@pkg/bwe/kalman.go
@pkg/bwe/trendline.go
@pkg/bwe/overuse.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add abs-capture-time parsing</name>
  <files>pkg/bwe/timestamp.go</files>
  <action>
Extend `pkg/bwe/timestamp.go` with abs-capture-time support:

1. Add constants for abs-capture-time (64-bit UQ32.32 format):
```go
// AbsCaptureTime uses UQ32.32 format: 32 bits for seconds, 32 bits for fractions
// Resolution is 1/2^32 seconds (~233 picoseconds)
const AbsCaptureTimeResolution = 1.0 / (1 << 32) // seconds per unit
```

2. Add `ParseAbsCaptureTime(data []byte) (uint64, error)`:
   - Return error if len(data) < 8
   - Parse 8 bytes big-endian into uint64
   - `(uint64(data[0])<<56) | (uint64(data[1])<<48) | ... | uint64(data[7])`

3. Add `AbsCaptureTimeToDuration(value uint64) time.Duration`:
   - Split into seconds (upper 32 bits) and fraction (lower 32 bits)
   - `seconds := value >> 32`
   - `fraction := value & 0xFFFFFFFF`
   - Return `time.Duration(seconds)*time.Second + time.Duration(float64(fraction)*AbsCaptureTimeResolution*float64(time.Second))`

4. Add `UnwrapAbsCaptureTime(prev, curr uint64) int64`:
   - Similar to abs-send-time but with 64-bit range
   - Wraparound period is ~136 years, so simple subtraction is sufficient
   - `return int64(curr) - int64(prev)` (signed)
   - For practical purposes, no wraparound handling needed within any reasonable session

5. Add `UnwrapAbsCaptureTimeDuration(prev, curr uint64) time.Duration`:
   - Get delta: `delta := UnwrapAbsCaptureTime(prev, curr)`
   - Convert to duration using AbsCaptureTimeResolution

6. Add tests in timestamp_test.go for abs-capture-time:
   - Parse 8-byte value
   - Convert to duration (verify seconds + fraction)
   - Unwrap returns correct delta
  </action>
  <verify>
`go test ./pkg/bwe/... -v -run AbsCapture` passes
  </verify>
  <done>
Abs-capture-time 64-bit UQ32.32 format parsing implemented with conversion to duration and unwrapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create DelayEstimator orchestrator</name>
  <files>pkg/bwe/estimator.go</files>
  <action>
Create `pkg/bwe/estimator.go` to wire all components:

1. Define filter type enum:
```go
type FilterType int

const (
    FilterKalman FilterType = iota
    FilterTrendline
)
```

2. Define `DelayEstimatorConfig`:
```go
type DelayEstimatorConfig struct {
    FilterType     FilterType
    BurstThreshold time.Duration
    KalmanConfig   KalmanConfig    // Used if FilterType == FilterKalman
    TrendlineConfig TrendlineConfig // Used if FilterType == FilterTrendline
    OveruseConfig  OveruseConfig
}

func DefaultDelayEstimatorConfig() DelayEstimatorConfig {
    return DelayEstimatorConfig{
        FilterType:      FilterKalman, // Kalman is traditional, Trendline is modern default
        BurstThreshold:  5 * time.Millisecond,
        KalmanConfig:    DefaultKalmanConfig(),
        TrendlineConfig: DefaultTrendlineConfig(),
        OveruseConfig:   DefaultOveruseConfig(),
    }
}
```

3. Define filter interface:
```go
// delayFilter is internal interface for Kalman and Trendline
type delayFilter interface {
    Update(arrivalTime time.Time, delayMs float64) float64
    Reset()
}

// Adapter for KalmanFilter (ignores arrivalTime)
type kalmanAdapter struct {
    filter *KalmanFilter
}

func (k *kalmanAdapter) Update(arrivalTime time.Time, delayMs float64) float64 {
    return k.filter.Update(delayMs)
}

func (k *kalmanAdapter) Reset() { k.filter.Reset() }
```

4. Define `DelayEstimator`:
```go
type DelayEstimator struct {
    config      DelayEstimatorConfig
    clock       Clock
    interarrival *InterArrivalCalculator
    filter      delayFilter
    detector    *OveruseDetector
}
```

5. Constructor `NewDelayEstimator(config DelayEstimatorConfig, clock Clock)`:
   - If clock is nil, use MonotonicClock{}
   - Create InterArrivalCalculator with config.BurstThreshold
   - Create filter based on config.FilterType
   - Create OveruseDetector with config.OveruseConfig and clock

6. Method `(e *DelayEstimator) OnPacket(pkt PacketInfo) BandwidthUsage`:
```go
// Feed packet to inter-arrival calculator
delayVariation, hasResult := e.interarrival.AddPacket(pkt)
if !hasResult {
    // Still accumulating group, return current state
    return e.detector.State()
}

// Convert delay variation to milliseconds for filter
delayMs := float64(delayVariation.Microseconds()) / 1000.0

// Feed to filter (Kalman or Trendline)
estimate := e.filter.Update(pkt.ArrivalTime, delayMs)

// Feed estimate to overuse detector
return e.detector.Detect(estimate)
```

7. Method `(e *DelayEstimator) State() BandwidthUsage`:
   - Return detector.State()

8. Method `(e *DelayEstimator) SetCallback(cb StateChangeCallback)`:
   - Forward to detector.SetCallback(cb)

9. Method `(e *DelayEstimator) Reset()`:
   - Reset all components: interarrival, filter, detector
  </action>
  <verify>
`go build ./pkg/bwe/...` succeeds
  </verify>
  <done>
DelayEstimator orchestrates InterArrivalCalculator, Kalman/Trendline filter, and OveruseDetector into a single OnPacket() API.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create test utilities and integration tests</name>
  <files>pkg/bwe/testutil/traces.go, pkg/bwe/estimator_test.go</files>
  <action>
1. Create `pkg/bwe/testutil/traces.go` with synthetic packet generators:

```go
package testutil

import (
    "time"
    "multicodecsimulcast/pkg/bwe"
    "multicodecsimulcast/pkg/bwe/internal"
)

// TracePacket extends PacketInfo with send timestamp for trace generation
type TracePacket struct {
    bwe.PacketInfo
    SendTimeMs float64 // For trace description
}

// StableNetworkTrace generates packets with constant delay (no congestion)
// Packets arrive at same rate as sent
func StableNetworkTrace(clock *internal.MockClock, count int, intervalMs int) []TracePacket {
    packets := make([]TracePacket, count)
    sendTime := uint32(0)

    for i := 0; i < count; i++ {
        packets[i] = TracePacket{
            PacketInfo: bwe.PacketInfo{
                ArrivalTime: clock.Now(),
                SendTime:    sendTime,
                Size:        1200,
                SSRC:        0x12345678,
            },
            SendTimeMs: float64(i * intervalMs),
        }
        // Both send and receive advance by same interval
        sendTime += uint32(intervalMs * 262) // ~262 units per ms
        clock.Advance(time.Duration(intervalMs) * time.Millisecond)
    }
    return packets
}

// CongestingNetworkTrace generates packets where receive delay increases
// Simulates queue building: each packet arrives slightly later than expected
func CongestingNetworkTrace(clock *internal.MockClock, count int, intervalMs int, delayIncreaseMs float64) []TracePacket {
    packets := make([]TracePacket, count)
    sendTime := uint32(0)
    accumulatedDelay := 0.0

    for i := 0; i < count; i++ {
        packets[i] = TracePacket{
            PacketInfo: bwe.PacketInfo{
                ArrivalTime: clock.Now(),
                SendTime:    sendTime,
                Size:        1200,
                SSRC:        0x12345678,
            },
            SendTimeMs: float64(i * intervalMs),
        }
        // Send time advances normally
        sendTime += uint32(intervalMs * 262)
        // Receive time advances more (queue building)
        accumulatedDelay += delayIncreaseMs
        clock.Advance(time.Duration(float64(intervalMs)+delayIncreaseMs) * time.Millisecond)
    }
    return packets
}

// DrainingNetworkTrace generates packets where receive delay decreases
// Simulates queue draining: packets arrive faster than expected
func DrainingNetworkTrace(clock *internal.MockClock, count int, intervalMs int, delayDecreaseMs float64) []TracePacket {
    // Similar to CongestingNetworkTrace but receive advances less than send
    ...
}

// WraparoundTrace generates packets that exercise 24-bit wraparound
func WraparoundTrace(clock *internal.MockClock) []TracePacket {
    // Start near max (64 second mark), generate packets across wrap
    // AbsSendTimeMax = 16777216, which is ~64 seconds at 262144 units/sec
    ...
}
```

2. Create `pkg/bwe/estimator_test.go` with integration tests:

Test stable network:
- Generate StableNetworkTrace with 100 packets, 20ms intervals
- Feed all to DelayEstimator
- Final state should be BwNormal
- No state change callbacks triggered

Test congesting network:
- Generate CongestingNetworkTrace with +2ms delay increase per packet
- Feed to DelayEstimator
- State should eventually transition to BwOverusing
- Verify callback fired with correct states

Test draining network:
- Generate DrainingNetworkTrace with -2ms delay decrease per packet
- State should transition to BwUnderusing

Test recovery from congestion:
- Start with congesting trace until BwOverusing
- Then stable trace
- State should return to BwNormal

Test wraparound handling:
- Generate WraparoundTrace that crosses 64-second boundary
- Feed to DelayEstimator
- Should not produce huge delay spikes or incorrect states

Test with Trendline filter:
- Same traces but with FilterTrendline
- Should produce similar (not identical) results

Test monotonic time usage (PERF-03):
- Create custom Clock that panics if time goes backward
- Run full trace through estimator
- No panics = monotonic time used correctly
  </action>
  <verify>
`go test ./pkg/bwe/... -v` passes all integration tests
  </verify>
  <done>
Test utilities generate stable/congesting/draining/wraparound traces. Integration tests prove full pipeline produces correct congestion signals for various network conditions.
  </done>
</task>

</tasks>

<verification>
1. `go test ./pkg/bwe/... -v` passes all tests
2. Stable network trace: estimator stays BwNormal
3. Congesting network trace: estimator transitions to BwOverusing
4. Draining network trace: estimator transitions to BwUnderusing
5. Wraparound trace: no incorrect state transitions or crashes
6. Both Kalman and Trendline filters work with estimator
</verification>

<success_criteria>
- TIME-03: Abs-capture-time parsing implemented as alternative input
- PERF-03: Monotonic time used consistently (verified by tests)
- All Phase 1 components integrated into working pipeline
- Integration tests prove correct behavior for stable, congesting, and draining networks
- Wraparound edge cases handled correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-pipeline/01-06-SUMMARY.md`
</output>
