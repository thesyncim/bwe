---
phase: 03-pion-integration
plan: 06
type: execute
wave: 5
depends_on: ["03-05"]
files_modified:
  - pkg/bwe/interceptor/pool.go
  - pkg/bwe/interceptor/interceptor.go
  - pkg/bwe/interceptor/interceptor_test.go
  - pkg/bwe/interceptor/integration_test.go
autonomous: true

must_haves:
  truths:
    - "sync.Pool is used for packet metadata to reduce allocations"
    - "PacketInfo objects are pooled and reused across packets"
    - "Integration tests verify end-to-end interceptor behavior"
    - "All Phase 3 requirements are verified in a single test"
  artifacts:
    - path: "pkg/bwe/interceptor/pool.go"
      provides: "sync.Pool for PacketInfo reuse"
      exports: ["packetInfoPool"]
    - path: "pkg/bwe/interceptor/integration_test.go"
      provides: "End-to-end integration tests"
      min_lines: 100
  key_links:
    - from: "pkg/bwe/interceptor/interceptor.go"
      to: "pkg/bwe/interceptor/pool.go"
      via: "Pool Get/Put in processRTP"
      pattern: "packetInfoPool\\.(Get|Put)"
    - from: "pkg/bwe/interceptor/integration_test.go"
      to: "pkg/bwe/interceptor/factory.go"
      via: "Factory creation in tests"
      pattern: "NewBWEInterceptorFactory"
---

<objective>
Add sync.Pool optimization and comprehensive integration tests.

Purpose: Optimize packet processing to minimize allocations (PERF-02) and verify all Phase 3 requirements are met through integration testing.

Output:
- sync.Pool for PacketInfo to reduce GC pressure
- Integration tests simulating real interceptor usage
- Requirements verification test covering all Phase 3 requirements
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-pion-integration/03-RESEARCH.md

Phase 3 Requirements to verify:
- TIME-04: Auto-detect extension IDs from SDP negotiation
- PION-01: Implement Pion Interceptor interface
- PION-02: Implement BindRemoteStream for RTP packet observation
- PION-03: Implement BindRTCPWriter for REMB packet output
- PION-04: Handle stream timeout with graceful cleanup after 2s inactivity
- PION-05: Provide InterceptorFactory for PeerConnection integration
- PERF-02: Use sync.Pool for packet metadata structures

Success criteria from roadmap:
1. Interceptor integrates with Pion PeerConnection via InterceptorFactory
2. RTP packets observed without blocking media pipeline
3. REMB packets sent at configurable intervals (default 1Hz)
4. Extension IDs auto-detected from SDP negotiation
5. Streams timeout gracefully after 2 seconds
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create sync.Pool for PacketInfo</name>
  <files>pkg/bwe/interceptor/pool.go</files>
  <action>
Create pkg/bwe/interceptor/pool.go with sync.Pool for packet metadata:

```go
package interceptor

import (
    "sync"

    "bwe/pkg/bwe"
)

// packetInfoPool provides reusable PacketInfo objects to reduce allocations.
// On the hot path (every RTP packet), we allocate a PacketInfo to feed to
// the estimator. Using a pool reduces GC pressure.
var packetInfoPool = sync.Pool{
    New: func() any {
        return &bwe.PacketInfo{}
    },
}

// getPacketInfo retrieves a PacketInfo from the pool.
// The returned object should be returned via putPacketInfo after use.
func getPacketInfo() *bwe.PacketInfo {
    return packetInfoPool.Get().(*bwe.PacketInfo)
}

// putPacketInfo returns a PacketInfo to the pool for reuse.
// The object is reset to zero values before returning to pool.
func putPacketInfo(p *bwe.PacketInfo) {
    // Reset all fields to avoid data leaking between uses
    p.ArrivalTime = time.Time{}
    p.SendTime = 0
    p.Size = 0
    p.SSRC = 0
    packetInfoPool.Put(p)
}
```

Add import for "time".

Key points:
- Pool.New creates zero-value PacketInfo
- putPacketInfo resets fields before returning (avoid data leaks)
- Used in processRTP on every packet
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>sync.Pool created for PacketInfo</done>
</task>

<task type="auto">
  <name>Task 2: Use pool in processRTP</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Update processRTP in pkg/bwe/interceptor/interceptor.go to use the pool:

Find the section where PacketInfo is created (around line 260 from Plan 02):
```go
// OLD CODE:
pkt := bwe.PacketInfo{
    ArrivalTime: now,
    SendTime:    sendTime,
    Size:        len(raw),
    SSRC:        ssrc,
}
i.estimator.OnPacket(pkt)
```

Replace with pooled version:
```go
// NEW CODE (using pool):
pkt := getPacketInfo()
pkt.ArrivalTime = now
pkt.SendTime = sendTime
pkt.Size = len(raw)
pkt.SSRC = ssrc

i.estimator.OnPacket(*pkt) // Pass by value to estimator

putPacketInfo(pkt) // Return to pool for reuse
```

Note: We pass *pkt dereferenced to OnPacket because:
1. BandwidthEstimator.OnPacket takes PacketInfo by value (not pointer)
2. This is safe because OnPacket doesn't store the PacketInfo
3. After OnPacket returns, we can safely reset and return to pool

Alternative if OnPacket stored the PacketInfo (it doesn't):
```go
// Would need to NOT return to pool, or change OnPacket signature
```

Verify BandwidthEstimator.OnPacket doesn't retain the PacketInfo reference - it just reads fields and discards.
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...` and `go test ./pkg/bwe/interceptor/... -race`</verify>
  <done>processRTP uses sync.Pool for PacketInfo</done>
</task>

<task type="auto">
  <name>Task 3: Create integration tests</name>
  <files>pkg/bwe/interceptor/integration_test.go</files>
  <action>
Create pkg/bwe/interceptor/integration_test.go with comprehensive integration tests:

```go
package interceptor

import (
    "bytes"
    "testing"
    "time"

    "github.com/pion/interceptor"
    "github.com/pion/rtcp"
    "github.com/pion/rtp"
    "github.com/stretchr/testify/assert"
    "github.com/stretchr/testify/require"
)

// TestIntegration_EndToEnd verifies the complete interceptor flow:
// Factory -> Interceptor -> BindRemoteStream -> ProcessRTP -> BindRTCPWriter -> REMB
func TestIntegration_EndToEnd(t *testing.T) {
    // 1. Create factory (PION-05)
    factory, err := NewBWEInterceptorFactory(
        WithREMBInterval(100 * time.Millisecond), // Fast for testing
    )
    require.NoError(t, err)

    // 2. Create interceptor (PION-01)
    i, err := factory.NewInterceptor("test")
    require.NoError(t, err)
    bwei := i.(*BWEInterceptor)
    defer bwei.Close()

    // 3. Create mock RTCP writer to capture REMB packets (PION-03)
    writer := &captureRTCPWriter{}
    _ = bwei.BindRTCPWriter(writer)

    // 4. Bind remote stream with extension info (TIME-04, PION-02)
    streamInfo := &interceptor.StreamInfo{
        SSRC: 12345,
        RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
            {URI: AbsSendTimeURI, ID: 3},
        },
    }
    mockReader := &mockRTPReaderWithData{
        packets: generateRTPPackets(12345, 3, 20), // 20 packets
    }
    reader := bwei.BindRemoteStream(streamInfo, mockReader)

    // 5. Read packets through the wrapped reader
    buf := make([]byte, 1500)
    for i := 0; i < 20; i++ {
        _, _, err := reader.Read(buf, nil)
        if err != nil {
            break
        }
        time.Sleep(10 * time.Millisecond) // Simulate real-time arrival
    }

    // 6. Wait for REMB to be sent
    time.Sleep(200 * time.Millisecond)

    // 7. Verify REMB was sent (PION-03)
    pkts := writer.getPackets()
    require.NotEmpty(t, pkts, "should have sent REMB")

    // Find REMB packet
    var remb *rtcp.ReceiverEstimatedMaximumBitrate
    for _, pkt := range pkts {
        if r, ok := pkt.(*rtcp.ReceiverEstimatedMaximumBitrate); ok {
            remb = r
            break
        }
    }
    require.NotNil(t, remb, "should have REMB packet")
    assert.Contains(t, remb.SSRCs, uint32(12345), "REMB should include stream SSRC")
    assert.Greater(t, remb.Bitrate, float32(0), "REMB should have positive bitrate")
}

// TestIntegration_MultiStream verifies multi-SSRC handling
func TestIntegration_MultiStream(t *testing.T) {
    factory, err := NewBWEInterceptorFactory(
        WithREMBInterval(100 * time.Millisecond),
    )
    require.NoError(t, err)

    i, err := factory.NewInterceptor("test")
    require.NoError(t, err)
    bwei := i.(*BWEInterceptor)
    defer bwei.Close()

    writer := &captureRTCPWriter{}
    _ = bwei.BindRTCPWriter(writer)

    // Bind two streams with different SSRCs
    stream1 := &interceptor.StreamInfo{
        SSRC: 11111,
        RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
            {URI: AbsSendTimeURI, ID: 3},
        },
    }
    stream2 := &interceptor.StreamInfo{
        SSRC: 22222,
        RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
            {URI: AbsSendTimeURI, ID: 3},
        },
    }

    reader1 := bwei.BindRemoteStream(stream1, &mockRTPReaderWithData{
        packets: generateRTPPackets(11111, 3, 10),
    })
    reader2 := bwei.BindRemoteStream(stream2, &mockRTPReaderWithData{
        packets: generateRTPPackets(22222, 3, 10),
    })

    // Read from both streams
    buf := make([]byte, 1500)
    for i := 0; i < 10; i++ {
        reader1.Read(buf, nil)
        reader2.Read(buf, nil)
        time.Sleep(5 * time.Millisecond)
    }

    // Wait for REMB
    time.Sleep(200 * time.Millisecond)

    // Verify REMB includes both SSRCs
    pkts := writer.getPackets()
    var remb *rtcp.ReceiverEstimatedMaximumBitrate
    for _, pkt := range pkts {
        if r, ok := pkt.(*rtcp.ReceiverEstimatedMaximumBitrate); ok {
            remb = r
            break
        }
    }
    require.NotNil(t, remb)
    assert.Len(t, remb.SSRCs, 2, "REMB should include both SSRCs")
    assert.Contains(t, remb.SSRCs, uint32(11111))
    assert.Contains(t, remb.SSRCs, uint32(22222))
}

// TestIntegration_StreamTimeout verifies streams are cleaned up (PION-04)
func TestIntegration_StreamTimeout(t *testing.T) {
    if testing.Short() {
        t.Skip("skipping timeout test in short mode")
    }

    factory, err := NewBWEInterceptorFactory()
    require.NoError(t, err)

    i, err := factory.NewInterceptor("test")
    require.NoError(t, err)
    bwei := i.(*BWEInterceptor)
    defer bwei.Close()

    // Bind stream
    streamInfo := &interceptor.StreamInfo{
        SSRC: 99999,
        RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
            {URI: AbsSendTimeURI, ID: 3},
        },
    }
    reader := bwei.BindRemoteStream(streamInfo, &mockRTPReaderWithData{
        packets: generateRTPPackets(99999, 3, 5),
    })

    // Read a few packets
    buf := make([]byte, 1500)
    for i := 0; i < 5; i++ {
        reader.Read(buf, nil)
    }

    // Verify stream is tracked
    _, exists := bwei.streams.Load(uint32(99999))
    require.True(t, exists, "stream should exist initially")

    // Wait for timeout (>2 seconds)
    time.Sleep(3 * time.Second)

    // Verify stream is removed
    _, exists = bwei.streams.Load(uint32(99999))
    assert.False(t, exists, "stream should be removed after timeout")
}

// Helper: generate RTP packets with abs-send-time extension
func generateRTPPackets(ssrc uint32, extID uint8, count int) [][]byte {
    packets := make([][]byte, count)
    baseTime := uint32(0x100000) // Start at some arbitrary point

    for i := 0; i < count; i++ {
        // Build RTP packet with one-byte header extension
        pkt := &rtp.Packet{
            Header: rtp.Header{
                Version:        2,
                PayloadType:    96,
                SequenceNumber: uint16(i),
                Timestamp:      uint32(i * 3000),
                SSRC:           ssrc,
            },
            Payload: make([]byte, 100), // 100 byte payload
        }

        // Add abs-send-time extension
        sendTime := baseTime + uint32(i*1000) // ~3.8ms increments
        extData := []byte{
            byte(sendTime >> 16),
            byte(sendTime >> 8),
            byte(sendTime),
        }
        pkt.Header.SetExtension(extID, extData)

        // Marshal to bytes
        data, _ := pkt.Marshal()
        packets[i] = data
    }
    return packets
}

// Helper: mock RTP reader with pre-generated packets
type mockRTPReaderWithData struct {
    packets [][]byte
    idx     int
}

func (m *mockRTPReaderWithData) Read(b []byte, a interceptor.Attributes) (int, interceptor.Attributes, error) {
    if m.idx >= len(m.packets) {
        return 0, a, io.EOF
    }
    n := copy(b, m.packets[m.idx])
    m.idx++
    return n, a, nil
}

// Helper: capture RTCP writer
type captureRTCPWriter struct {
    mu      sync.Mutex
    packets []rtcp.Packet
}

func (w *captureRTCPWriter) Write(pkts []rtcp.Packet, _ interceptor.Attributes) (int, error) {
    w.mu.Lock()
    defer w.mu.Unlock()
    w.packets = append(w.packets, pkts...)
    return len(pkts), nil
}

func (w *captureRTCPWriter) getPackets() []rtcp.Packet {
    w.mu.Lock()
    defer w.mu.Unlock()
    result := make([]rtcp.Packet, len(w.packets))
    copy(result, w.packets)
    return result
}
```

Add imports for "io", "sync".
  </action>
  <verify>Run `go test ./pkg/bwe/interceptor/... -v -run Integration`</verify>
  <done>Integration tests verify end-to-end flow</done>
</task>

<task type="auto">
  <name>Task 4: Create Phase 3 requirements verification test</name>
  <files>pkg/bwe/interceptor/integration_test.go</files>
  <action>
Add requirements verification test to integration_test.go:

```go
// TestPhase3_RequirementsVerification verifies all Phase 3 requirements
// are met. Each test validates specific requirement(s).
func TestPhase3_RequirementsVerification(t *testing.T) {
    t.Run("TIME-04: Extension IDs from SDP", func(t *testing.T) {
        factory, err := NewBWEInterceptorFactory()
        require.NoError(t, err)

        i, err := factory.NewInterceptor("test")
        require.NoError(t, err)
        bwei := i.(*BWEInterceptor)
        defer bwei.Close()

        // Before binding, extension IDs should be 0
        assert.Equal(t, uint32(0), bwei.absExtID.Load())
        assert.Equal(t, uint32(0), bwei.captureExtID.Load())

        // Bind stream with extension info
        streamInfo := &interceptor.StreamInfo{
            SSRC: 12345,
            RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
                {URI: AbsSendTimeURI, ID: 5},
                {URI: AbsCaptureTimeURI, ID: 7},
            },
        }
        bwei.BindRemoteStream(streamInfo, &mockRTPReaderWithData{})

        // After binding, extension IDs should be set from SDP
        assert.Equal(t, uint32(5), bwei.absExtID.Load())
        assert.Equal(t, uint32(7), bwei.captureExtID.Load())
    })

    t.Run("PION-01: Interceptor interface", func(t *testing.T) {
        factory, err := NewBWEInterceptorFactory()
        require.NoError(t, err)

        i, err := factory.NewInterceptor("test")
        require.NoError(t, err)

        // Verify it implements interceptor.Interceptor
        var _ interceptor.Interceptor = i

        i.(*BWEInterceptor).Close()
    })

    t.Run("PION-02: BindRemoteStream", func(t *testing.T) {
        factory, err := NewBWEInterceptorFactory()
        require.NoError(t, err)

        i, err := factory.NewInterceptor("test")
        require.NoError(t, err)
        bwei := i.(*BWEInterceptor)
        defer bwei.Close()

        streamInfo := &interceptor.StreamInfo{
            SSRC: 54321,
            RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
                {URI: AbsSendTimeURI, ID: 3},
            },
        }
        mockReader := &mockRTPReaderWithData{
            packets: generateRTPPackets(54321, 3, 5),
        }

        // BindRemoteStream should return a wrapped reader
        reader := bwei.BindRemoteStream(streamInfo, mockReader)
        require.NotNil(t, reader)
        assert.NotSame(t, reader, mockReader, "should return wrapped reader")

        // Stream should be tracked
        _, exists := bwei.streams.Load(uint32(54321))
        assert.True(t, exists, "stream should be tracked")

        // Reading through wrapped reader should work
        buf := make([]byte, 1500)
        n, _, err := reader.Read(buf, nil)
        assert.NoError(t, err)
        assert.Greater(t, n, 0)
    })

    t.Run("PION-03: BindRTCPWriter REMB output", func(t *testing.T) {
        factory, err := NewBWEInterceptorFactory(
            WithREMBInterval(50 * time.Millisecond),
        )
        require.NoError(t, err)

        i, err := factory.NewInterceptor("test")
        require.NoError(t, err)
        bwei := i.(*BWEInterceptor)
        defer bwei.Close()

        // Bind stream and process packets
        streamInfo := &interceptor.StreamInfo{
            SSRC: 11111,
            RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
                {URI: AbsSendTimeURI, ID: 3},
            },
        }
        reader := bwei.BindRemoteStream(streamInfo, &mockRTPReaderWithData{
            packets: generateRTPPackets(11111, 3, 10),
        })

        buf := make([]byte, 1500)
        for i := 0; i < 10; i++ {
            reader.Read(buf, nil)
        }

        // Now bind RTCP writer
        writer := &captureRTCPWriter{}
        returned := bwei.BindRTCPWriter(writer)
        assert.Same(t, writer, returned, "should return same writer (passthrough)")

        // Wait for REMB
        time.Sleep(100 * time.Millisecond)

        // Verify REMB was written
        pkts := writer.getPackets()
        hasREMB := false
        for _, pkt := range pkts {
            if _, ok := pkt.(*rtcp.ReceiverEstimatedMaximumBitrate); ok {
                hasREMB = true
                break
            }
        }
        assert.True(t, hasREMB, "should have sent REMB via RTCPWriter")
    })

    t.Run("PION-04: Stream timeout", func(t *testing.T) {
        if testing.Short() {
            t.Skip("skipping timeout test in short mode")
        }

        factory, err := NewBWEInterceptorFactory()
        require.NoError(t, err)

        i, err := factory.NewInterceptor("test")
        require.NoError(t, err)
        bwei := i.(*BWEInterceptor)
        defer bwei.Close()

        streamInfo := &interceptor.StreamInfo{
            SSRC: 88888,
            RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
                {URI: AbsSendTimeURI, ID: 3},
            },
        }
        reader := bwei.BindRemoteStream(streamInfo, &mockRTPReaderWithData{
            packets: generateRTPPackets(88888, 3, 2),
        })

        // Process packets
        buf := make([]byte, 1500)
        reader.Read(buf, nil)
        reader.Read(buf, nil)

        // Stream exists
        _, exists := bwei.streams.Load(uint32(88888))
        require.True(t, exists)

        // Wait > 2 seconds
        time.Sleep(2500 * time.Millisecond)

        // Stream should be removed
        _, exists = bwei.streams.Load(uint32(88888))
        assert.False(t, exists, "stream should timeout after 2s inactivity")
    })

    t.Run("PION-05: InterceptorFactory", func(t *testing.T) {
        // Create factory
        factory, err := NewBWEInterceptorFactory(
            WithInitialBitrate(1000000),
            WithREMBInterval(500 * time.Millisecond),
        )
        require.NoError(t, err)

        // Verify it implements interceptor.Factory
        var _ interceptor.Factory = factory

        // Create multiple interceptors (simulating multiple PeerConnections)
        i1, err := factory.NewInterceptor("pc-1")
        require.NoError(t, err)
        i2, err := factory.NewInterceptor("pc-2")
        require.NoError(t, err)

        // Each interceptor is independent
        assert.NotSame(t, i1, i2)

        // Clean up
        i1.(*BWEInterceptor).Close()
        i2.(*BWEInterceptor).Close()
    })

    t.Run("PERF-02: sync.Pool for PacketInfo", func(t *testing.T) {
        // This test verifies the pool exists and works
        // (actual allocation reduction is verified via benchmarks)

        // Get from pool
        p1 := getPacketInfo()
        require.NotNil(t, p1)

        // Modify it
        p1.SSRC = 12345
        p1.Size = 1000

        // Return to pool
        putPacketInfo(p1)

        // Get again (may or may not be same object)
        p2 := getPacketInfo()
        require.NotNil(t, p2)

        // Should be reset
        assert.Equal(t, uint32(0), p2.SSRC, "pooled object should be reset")
        assert.Equal(t, 0, p2.Size, "pooled object should be reset")

        putPacketInfo(p2)
    })
}
```
  </action>
  <verify>Run `go test ./pkg/bwe/interceptor/... -v -run RequirementsVerification`</verify>
  <done>Phase 3 requirements verification test passes</done>
</task>

</tasks>

<verification>
```bash
# Build package
go build ./pkg/bwe/interceptor/...

# Run all tests
go test ./pkg/bwe/interceptor/... -v

# Run with race detector
go test ./pkg/bwe/interceptor/... -v -race

# Run integration tests specifically
go test ./pkg/bwe/interceptor/... -v -run Integration

# Run requirements verification
go test ./pkg/bwe/interceptor/... -v -run RequirementsVerification

# Run timeout tests (slow)
go test ./pkg/bwe/interceptor/... -v -run Timeout -timeout 30s

# Verify pool is used (check that getPacketInfo/putPacketInfo are called in processRTP)
grep -n "getPacketInfo\|putPacketInfo" pkg/bwe/interceptor/interceptor.go
```
</verification>

<success_criteria>
- sync.Pool created for PacketInfo (pool.go)
- processRTP uses pool Get/Put for PacketInfo
- Integration tests verify end-to-end flow
- Multi-stream test verifies SSRC aggregation
- Stream timeout test verifies 2s cleanup (PION-04)
- Phase 3 requirements test covers all 7 requirements
- All tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/03-pion-integration/03-06-SUMMARY.md`
</output>
