---
phase: 03-pion-integration
plan: 04
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - pkg/bwe/interceptor/interceptor.go
  - pkg/bwe/interceptor/interceptor_test.go
autonomous: true

must_haves:
  truths:
    - "Streams inactive for >2 seconds are removed from tracking"
    - "Cleanup runs periodically without blocking RTP path"
    - "Close() waits for all goroutines to complete"
    - "No resource leaks after Close()"
  artifacts:
    - path: "pkg/bwe/interceptor/interceptor.go"
      provides: "cleanupLoop and Close implementation"
      exports: ["Close"]
  key_links:
    - from: "pkg/bwe/interceptor/interceptor.go"
      to: "sync.Map"
      via: "Range and Delete in cleanupLoop"
      pattern: "streams\\.Range.*streams\\.Delete"
---

<objective>
Implement stream timeout cleanup and proper Close() method for graceful shutdown.

Purpose: Ensure inactive streams are cleaned up after 2 seconds of inactivity to prevent memory leaks and stale SSRC entries in REMB packets. Implement proper Close() to stop all goroutines cleanly.

Output:
- cleanupLoop goroutine that removes inactive streams
- Close() method that signals shutdown and waits for goroutines
- Tests verifying timeout behavior and clean shutdown
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-pion-integration/03-RESEARCH.md

Key points from research:
- Track lastPacketTime per stream (done in Plan 02)
- Run periodic cleanup goroutine (1s interval is fine)
- Remove streams inactive > 2 seconds
- Use sync.WaitGroup for goroutine cleanup
- Signal via channel, wait for completion in Close()

Pitfall to avoid:
- Close() returning before goroutines finish causes test flakiness
- Must use wg.Wait() after signaling closed channel
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add stream timeout constant</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Add timeout constant at package level:

```go
const (
    // streamTimeout is how long to keep tracking an inactive stream.
    // Streams with no packets for this duration are removed.
    streamTimeout = 2 * time.Second
)
```

This matches the PION-04 requirement: "Handle stream timeout with graceful cleanup after 2s inactivity"
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>streamTimeout constant defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement cleanupLoop</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Add cleanupLoop method:

```go
func (i *BWEInterceptor) cleanupLoop() {
    defer i.wg.Done()

    ticker := time.NewTicker(time.Second)  // Check every second
    defer ticker.Stop()

    for {
        select {
        case <-i.closed:
            return
        case now := <-ticker.C:
            i.cleanupInactiveStreams(now)
        }
    }
}

func (i *BWEInterceptor) cleanupInactiveStreams(now time.Time) {
    i.streams.Range(func(key, value any) bool {
        state := value.(*streamState)
        if now.Sub(state.LastPacket()) > streamTimeout {
            i.streams.Delete(key)
        }
        return true  // Continue iteration
    })
}
```

Key points:
- Runs every second (sufficient granularity for 2s timeout)
- Uses sync.Map.Range for thread-safe iteration
- Deletes stale entries during iteration (sync.Map supports this)
- Uses atomic LastPacket() read from streamState
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>cleanupLoop removes streams inactive > 2s</done>
</task>

<task type="auto">
  <name>Task 3: Start cleanup goroutine and implement Close</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
1. Start cleanupLoop in BindRemoteStream (first stream) or in a dedicated start method.

Option A: Start on first BindRemoteStream call using sync.Once:

Add field to BWEInterceptor:
```go
type BWEInterceptor struct {
    // ... existing fields ...
    startOnce sync.Once
}
```

Update BindRemoteStream to start cleanup:
```go
func (i *BWEInterceptor) BindRemoteStream(info *interceptor.StreamInfo, reader interceptor.RTPReader) interceptor.RTPReader {
    // Start cleanup loop on first stream (only once)
    i.startOnce.Do(func() {
        i.wg.Add(1)
        go i.cleanupLoop()
    })

    // ... rest of existing implementation ...
}
```

2. Implement Close():
```go
func (i *BWEInterceptor) Close() error {
    // Signal all goroutines to stop
    close(i.closed)

    // Wait for all goroutines to finish
    i.wg.Wait()

    return nil
}
```

Key points:
- close(i.closed) signals both rembLoop and cleanupLoop
- wg.Wait() ensures both finish before Close() returns
- sync.Once ensures cleanup starts only once even with multiple streams
- Returns nil error (no cleanup can fail in our implementation)
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>Close() signals shutdown and waits for goroutines</done>
</task>

<task type="auto">
  <name>Task 4: Add timeout and close tests</name>
  <files>pkg/bwe/interceptor/interceptor_test.go</files>
  <action>
Add tests for stream timeout and close:

1. TestStreamTimeout_RemovesInactiveStreams:
   - Create interceptor
   - Bind stream and process some packets
   - Record initial stream count
   - Wait 3 seconds (> 2s timeout)
   - Verify stream removed from tracking

```go
func TestStreamTimeout_RemovesInactiveStreams(t *testing.T) {
    est := bwe.NewBandwidthEstimator(bwe.DefaultBandwidthEstimatorConfig(), nil)
    i := NewBWEInterceptor(est)
    defer i.Close()

    // Bind stream
    info := &interceptor.StreamInfo{SSRC: 12345, RTPHeaderExtensions: []interceptor.RTPHeaderExtension{
        {URI: AbsSendTimeURI, ID: 3},
    }}
    mockReader := &mockRTPReader{}
    i.BindRemoteStream(info, mockReader)

    // Process a packet to activate stream
    // ... simulate RTP processing ...

    // Verify stream exists
    _, exists := i.streams.Load(uint32(12345))
    require.True(t, exists, "stream should exist initially")

    // Wait for timeout
    time.Sleep(3 * time.Second)

    // Verify stream removed
    _, exists = i.streams.Load(uint32(12345))
    assert.False(t, exists, "stream should be removed after timeout")
}
```

2. TestClose_StopsGoroutines:
   - Create interceptor
   - Bind stream and RTCP writer (starts goroutines)
   - Call Close()
   - Verify Close() returns (doesn't hang)
   - Verify can't send more REMB after close

3. TestClose_Idempotent:
   - Call Close() multiple times
   - Verify no panic

4. TestClose_BeforeGoroutinesStarted:
   - Create interceptor but don't bind anything
   - Call Close()
   - Verify returns without error

Add mock RTPReader for testing:
```go
type mockRTPReader struct {
    data []byte
}

func (m *mockRTPReader) Read(b []byte, a interceptor.Attributes) (int, interceptor.Attributes, error) {
    if len(m.data) == 0 {
        return 0, a, io.EOF
    }
    n := copy(b, m.data)
    m.data = nil
    return n, a, nil
}
```
  </action>
  <verify>Run `go test ./pkg/bwe/interceptor/... -v -race -run "Timeout|Close"`</verify>
  <done>Timeout and close tests pass with race detector</done>
</task>

</tasks>

<verification>
```bash
# Build package
go build ./pkg/bwe/interceptor/...

# Run all tests with race detector
go test ./pkg/bwe/interceptor/... -v -race

# Run timeout-specific tests (may be slow due to 3s wait)
go test ./pkg/bwe/interceptor/... -v -run Timeout -timeout 10s

# Run close tests
go test ./pkg/bwe/interceptor/... -v -run Close

# Check for goroutine leaks (should complete cleanly)
go test ./pkg/bwe/interceptor/... -v -count=3
```
</verification>

<success_criteria>
- Streams inactive > 2 seconds are removed from tracking
- cleanupLoop runs periodically without blocking RTP
- Close() signals shutdown and waits for goroutines
- No goroutine leaks (tests complete cleanly)
- Tests pass with race detector
- Multiple Close() calls don't panic
</success_criteria>

<output>
After completion, create `.planning/phases/03-pion-integration/03-04-SUMMARY.md`
</output>
