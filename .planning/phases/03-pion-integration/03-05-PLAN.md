---
phase: 03-pion-integration
plan: 05
type: execute
wave: 4
depends_on: ["03-03", "03-04"]
files_modified:
  - pkg/bwe/interceptor/factory.go
  - pkg/bwe/interceptor/factory_test.go
  - pkg/bwe/interceptor/doc.go
autonomous: true

must_haves:
  truths:
    - "InterceptorFactory creates interceptor instances per PeerConnection"
    - "Factory accepts configuration options for REMB interval and initial bitrate"
    - "Factory implements interceptor.Factory interface from pion/interceptor"
    - "Package documentation explains integration with Pion WebRTC"
  artifacts:
    - path: "pkg/bwe/interceptor/factory.go"
      provides: "BWEInterceptorFactory for PeerConnection registration"
      exports: ["BWEInterceptorFactory", "NewBWEInterceptorFactory"]
    - path: "pkg/bwe/interceptor/doc.go"
      provides: "Package-level documentation"
      min_lines: 20
  key_links:
    - from: "pkg/bwe/interceptor/factory.go"
      to: "github.com/pion/interceptor.Factory"
      via: "NewInterceptor method implementation"
      pattern: "NewInterceptor.*interceptor\\.Interceptor"
    - from: "pkg/bwe/interceptor/factory.go"
      to: "pkg/bwe/interceptor/interceptor.go"
      via: "NewBWEInterceptor call"
      pattern: "NewBWEInterceptor"
---

<objective>
Implement InterceptorFactory for PeerConnection integration.

Purpose: Provide the factory pattern required by Pion's interceptor registry. This allows users to register the BWE interceptor with PeerConnection using the standard pattern.

Output:
- BWEInterceptorFactory implementing interceptor.Factory
- Factory options for configuration (REMB interval, initial bitrate, min/max rates)
- Package documentation with usage examples
- Tests verifying factory creates working interceptors
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-pion-integration/03-RESEARCH.md

Key patterns from research:
- Factory implements interceptor.Factory interface
- NewInterceptor(id string) (interceptor.Interceptor, error)
- Options pattern for configuration (functional options)
- Registration via interceptor.Registry.Add(factory)

Usage example from research:
```go
// Create interceptor registry
i := &interceptor.Registry{}

// Register BWE interceptor
bweFactory, _ := NewBWEInterceptorFactory()
i.Add(bweFactory)

// Create API
api := webrtc.NewAPI(
    webrtc.WithMediaEngine(m),
    webrtc.WithInterceptorRegistry(i),
)
```
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create factory types and options</name>
  <files>pkg/bwe/interceptor/factory.go</files>
  <action>
Create pkg/bwe/interceptor/factory.go with:

1. Package declaration and imports:
   - "time"
   - "github.com/pion/interceptor"
   - "bwe/pkg/bwe"

2. FactoryOption type for functional options:
```go
// FactoryOption configures the BWEInterceptorFactory.
type FactoryOption func(*BWEInterceptorFactory) error
```

3. BWEInterceptorFactory struct:
```go
// BWEInterceptorFactory creates BWEInterceptor instances for each PeerConnection.
// Register this factory with the interceptor registry to enable receiver-side
// bandwidth estimation.
type BWEInterceptorFactory struct {
    config       bwe.BandwidthEstimatorConfig
    rembInterval time.Duration
    senderSSRC   uint32
}
```

4. Option functions:
```go
// WithInitialBitrate sets the initial bandwidth estimate.
// Default: 300000 (300 kbps)
func WithInitialBitrate(bitrate int64) FactoryOption {
    return func(f *BWEInterceptorFactory) error {
        f.config.RateControllerConfig.InitialBitrate = bitrate
        return nil
    }
}

// WithMinBitrate sets the minimum bandwidth estimate.
// Default: 10000 (10 kbps)
func WithMinBitrate(bitrate int64) FactoryOption {
    return func(f *BWEInterceptorFactory) error {
        f.config.RateControllerConfig.MinBitrate = bitrate
        return nil
    }
}

// WithMaxBitrate sets the maximum bandwidth estimate.
// Default: 50000000 (50 Mbps)
func WithMaxBitrate(bitrate int64) FactoryOption {
    return func(f *BWEInterceptorFactory) error {
        f.config.RateControllerConfig.MaxBitrate = bitrate
        return nil
    }
}

// WithREMBInterval sets how often REMB packets are sent.
// Default: 1 second
func WithREMBInterval(interval time.Duration) FactoryOption {
    return func(f *BWEInterceptorFactory) error {
        if interval <= 0 {
            return errors.New("REMB interval must be positive")
        }
        f.rembInterval = interval
        return nil
    }
}

// WithSenderSSRC sets the sender SSRC for REMB packets.
// This identifies the receiver generating the REMB.
// Default: 0 (many implementations use 0)
func WithSenderSSRC(ssrc uint32) FactoryOption {
    return func(f *BWEInterceptorFactory) error {
        f.senderSSRC = ssrc
        return nil
    }
}
```

Add import for "errors".
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>Factory types and option functions defined</done>
</task>

<task type="auto">
  <name>Task 2: Implement NewBWEInterceptorFactory and NewInterceptor</name>
  <files>pkg/bwe/interceptor/factory.go</files>
  <action>
Add factory constructor and interceptor.Factory implementation:

1. Constructor:
```go
// NewBWEInterceptorFactory creates a new factory for BWEInterceptor instances.
// Configure the factory using FactoryOption functions.
//
// Example:
//
//	factory, err := NewBWEInterceptorFactory(
//	    WithInitialBitrate(500000),
//	    WithREMBInterval(500*time.Millisecond),
//	)
//	if err != nil {
//	    return err
//	}
//	registry.Add(factory)
func NewBWEInterceptorFactory(opts ...FactoryOption) (*BWEInterceptorFactory, error) {
    f := &BWEInterceptorFactory{
        config:       bwe.DefaultBandwidthEstimatorConfig(),
        rembInterval: time.Second,
        senderSSRC:   0,
    }
    for _, opt := range opts {
        if err := opt(f); err != nil {
            return nil, err
        }
    }
    return f, nil
}
```

2. Implement interceptor.Factory interface:
```go
// NewInterceptor creates a new BWEInterceptor for a PeerConnection.
// This method is called by the interceptor registry when setting up a connection.
func (f *BWEInterceptorFactory) NewInterceptor(id string) (interceptor.Interceptor, error) {
    // Create a new BandwidthEstimator with factory config
    estimator := bwe.NewBandwidthEstimator(f.config, nil)

    // Create interceptor with configured options
    i := NewBWEInterceptor(
        estimator,
        WithREMBInterval(f.rembInterval),
        WithSenderSSRC(f.senderSSRC),
    )

    return i, nil
}
```

Key points:
- Each PeerConnection gets its own BandwidthEstimator instance
- Factory config is cloned for each interceptor (not shared)
- The 'id' parameter from Pion is unused (we don't need it)
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>Factory implements interceptor.Factory interface</done>
</task>

<task type="auto">
  <name>Task 3: Add package documentation</name>
  <files>pkg/bwe/interceptor/doc.go</files>
  <action>
Create pkg/bwe/interceptor/doc.go with package-level documentation:

```go
// Package interceptor provides a Pion WebRTC interceptor for receiver-side
// bandwidth estimation using Google Congestion Control (GCC).
//
// This interceptor observes incoming RTP packets, extracts timing information
// from abs-send-time or abs-capture-time extensions, and generates REMB
// (Receiver Estimated Maximum Bitrate) RTCP feedback packets.
//
// # Quick Start
//
// Register the interceptor factory with your Pion WebRTC API:
//
//	import (
//	    "github.com/pion/interceptor"
//	    "github.com/pion/webrtc/v4"
//	    bweint "bwe/pkg/bwe/interceptor"
//	)
//
//	func setupPeerConnection() (*webrtc.PeerConnection, error) {
//	    // Create media engine with abs-send-time extension
//	    m := &webrtc.MediaEngine{}
//	    if err := m.RegisterDefaultCodecs(); err != nil {
//	        return nil, err
//	    }
//
//	    // Create interceptor registry
//	    i := &interceptor.Registry{}
//
//	    // Register BWE interceptor
//	    bweFactory, err := bweint.NewBWEInterceptorFactory()
//	    if err != nil {
//	        return nil, err
//	    }
//	    i.Add(bweFactory)
//
//	    // Create API
//	    api := webrtc.NewAPI(
//	        webrtc.WithMediaEngine(m),
//	        webrtc.WithInterceptorRegistry(i),
//	    )
//
//	    return api.NewPeerConnection(webrtc.Configuration{})
//	}
//
// # Configuration
//
// The factory accepts options to customize behavior:
//
//	factory, err := bweint.NewBWEInterceptorFactory(
//	    bweint.WithInitialBitrate(500000),    // Start at 500 kbps
//	    bweint.WithMinBitrate(50000),         // Never go below 50 kbps
//	    bweint.WithMaxBitrate(10000000),      // Cap at 10 Mbps
//	    bweint.WithREMBInterval(500*time.Millisecond), // Send REMB twice per second
//	)
//
// # How It Works
//
// 1. When a remote stream is bound (BindRemoteStream), the interceptor extracts
//    extension IDs for abs-send-time and abs-capture-time from the SDP negotiation.
//
// 2. For each incoming RTP packet, the interceptor parses the timing extension,
//    computes inter-arrival delay variations, and updates the bandwidth estimate.
//
// 3. When the RTCP writer is bound (BindRTCPWriter), the interceptor starts a
//    background goroutine that sends REMB packets at configured intervals.
//
// 4. Inactive streams (no packets for 2 seconds) are automatically cleaned up.
//
// # Requirements
//
// The sender must include abs-send-time or abs-capture-time RTP header extensions.
// Register the appropriate extension with your MediaEngine to enable SDP negotiation.
package interceptor
```
  </action>
  <verify>Run `go doc ./pkg/bwe/interceptor/`</verify>
  <done>Package documentation with usage examples created</done>
</task>

<task type="auto">
  <name>Task 4: Add factory tests</name>
  <files>pkg/bwe/interceptor/factory_test.go</files>
  <action>
Create pkg/bwe/interceptor/factory_test.go with:

1. Test factory construction with defaults:
```go
func TestNewBWEInterceptorFactory_Defaults(t *testing.T) {
    factory, err := NewBWEInterceptorFactory()
    require.NoError(t, err)
    require.NotNil(t, factory)

    // Verify defaults
    assert.Equal(t, time.Second, factory.rembInterval)
    assert.Equal(t, uint32(0), factory.senderSSRC)
}
```

2. Test factory construction with options:
```go
func TestNewBWEInterceptorFactory_WithOptions(t *testing.T) {
    factory, err := NewBWEInterceptorFactory(
        WithInitialBitrate(500000),
        WithMinBitrate(50000),
        WithMaxBitrate(5000000),
        WithREMBInterval(500*time.Millisecond),
        WithSenderSSRC(12345),
    )
    require.NoError(t, err)

    assert.Equal(t, int64(500000), factory.config.RateControllerConfig.InitialBitrate)
    assert.Equal(t, int64(50000), factory.config.RateControllerConfig.MinBitrate)
    assert.Equal(t, int64(5000000), factory.config.RateControllerConfig.MaxBitrate)
    assert.Equal(t, 500*time.Millisecond, factory.rembInterval)
    assert.Equal(t, uint32(12345), factory.senderSSRC)
}
```

3. Test invalid options:
```go
func TestNewBWEInterceptorFactory_InvalidOption(t *testing.T) {
    _, err := NewBWEInterceptorFactory(
        WithREMBInterval(-1 * time.Second),
    )
    assert.Error(t, err)
    assert.Contains(t, err.Error(), "REMB interval")
}
```

4. Test NewInterceptor creates working interceptor:
```go
func TestBWEInterceptorFactory_NewInterceptor(t *testing.T) {
    factory, err := NewBWEInterceptorFactory()
    require.NoError(t, err)

    // Create interceptor
    i, err := factory.NewInterceptor("test-id")
    require.NoError(t, err)
    require.NotNil(t, i)

    // Verify it's a BWEInterceptor
    bwei, ok := i.(*BWEInterceptor)
    require.True(t, ok, "should be *BWEInterceptor")

    // Clean up
    err = bwei.Close()
    assert.NoError(t, err)
}
```

5. Test multiple interceptors are independent:
```go
func TestBWEInterceptorFactory_MultipleInterceptors(t *testing.T) {
    factory, err := NewBWEInterceptorFactory()
    require.NoError(t, err)

    // Create two interceptors
    i1, err := factory.NewInterceptor("pc-1")
    require.NoError(t, err)
    defer i1.(*BWEInterceptor).Close()

    i2, err := factory.NewInterceptor("pc-2")
    require.NoError(t, err)
    defer i2.(*BWEInterceptor).Close()

    // Verify they're different instances
    assert.NotSame(t, i1, i2)

    // Verify their estimators are different (not shared)
    bwei1 := i1.(*BWEInterceptor)
    bwei2 := i2.(*BWEInterceptor)
    assert.NotSame(t, bwei1.estimator, bwei2.estimator)
}
```

Import testify/assert and testify/require.
  </action>
  <verify>Run `go test ./pkg/bwe/interceptor/... -v -run Factory`</verify>
  <done>Factory tests pass</done>
</task>

</tasks>

<verification>
```bash
# Build package
go build ./pkg/bwe/interceptor/...

# Run factory tests
go test ./pkg/bwe/interceptor/... -v -run Factory

# Run all interceptor tests
go test ./pkg/bwe/interceptor/... -v -race

# Verify docs render correctly
go doc ./pkg/bwe/interceptor/

# Verify interface compliance (should compile without error)
go build -o /dev/null ./pkg/bwe/interceptor/...
```
</verification>

<success_criteria>
- BWEInterceptorFactory implements interceptor.Factory interface
- Factory options work (WithInitialBitrate, WithREMBInterval, etc.)
- NewInterceptor creates independent interceptor instances
- Package documentation includes usage example
- Tests pass including race detector
</success_criteria>

<output>
After completion, create `.planning/phases/03-pion-integration/03-05-SUMMARY.md`
</output>
