---
phase: 03-pion-integration
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - pkg/bwe/interceptor/interceptor.go
  - pkg/bwe/interceptor/interceptor_test.go
autonomous: true

must_haves:
  truths:
    - "Interceptor embeds NoOp for interface compliance"
    - "BindRemoteStream extracts extension IDs from StreamInfo"
    - "RTP packets are observed and fed to BandwidthEstimator"
    - "Stream state is tracked per SSRC"
  artifacts:
    - path: "pkg/bwe/interceptor/interceptor.go"
      provides: "BWEInterceptor type with BindRemoteStream"
      exports: ["BWEInterceptor", "NewBWEInterceptor"]
    - path: "pkg/bwe/interceptor/interceptor_test.go"
      provides: "Unit tests for RTP processing"
      min_lines: 50
  key_links:
    - from: "pkg/bwe/interceptor/interceptor.go"
      to: "pkg/bwe.BandwidthEstimator"
      via: "OnPacket call in processRTP"
      pattern: "estimator\\.OnPacket"
    - from: "pkg/bwe/interceptor/interceptor.go"
      to: "github.com/pion/rtp"
      via: "Header.Unmarshal and GetExtension"
      pattern: "rtp\\.Header.*Unmarshal"
---

<objective>
Implement the core BWEInterceptor type with BindRemoteStream for RTP packet observation.

Purpose: Create the main interceptor that observes incoming RTP packets, extracts timing extensions, and feeds them to the BandwidthEstimator from Phase 2.

Output:
- BWEInterceptor type embedding interceptor.NoOp
- BindRemoteStream implementation that wraps RTPReader
- processRTP function that parses headers and calls estimator.OnPacket
- Unit tests verifying RTP packet processing
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-pion-integration/03-RESEARCH.md

Key patterns from research:
- Embed interceptor.NoOp to satisfy interface, override only needed methods
- Use interceptor.RTPReaderFunc to wrap the reader
- Parse RTP header with rtp.Header.Unmarshal()
- Extract extension bytes with header.GetExtension(extID)
- Store stream state in sync.Map

Existing API from Phase 2:
- bwe.BandwidthEstimator with OnPacket(PacketInfo) int64
- bwe.PacketInfo{ArrivalTime, SendTime, Size, SSRC}
- bwe.ParseAbsSendTime([]byte) (uint32, error)
- bwe.ParseAbsCaptureTime([]byte) (uint64, error)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create BWEInterceptor type</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Create pkg/bwe/interceptor/interceptor.go with:

1. Package declaration and imports:
   - "sync"
   - "sync/atomic"
   - "time"
   - "github.com/pion/interceptor"
   - "github.com/pion/rtp"
   - "bwe/pkg/bwe"

2. BWEInterceptor struct:
```go
type BWEInterceptor struct {
    interceptor.NoOp  // Embed for interface compliance

    estimator    *bwe.BandwidthEstimator
    streams      sync.Map  // SSRC (uint32) -> *streamState

    // Extension IDs (atomic for concurrent access)
    absExtID     atomic.Uint32
    captureExtID atomic.Uint32

    // RTCP writer and REMB scheduling (will be set in Plan 03)
    mu           sync.Mutex
    rtcpWriter   interceptor.RTCPWriter
    rembInterval time.Duration
    senderSSRC   uint32

    // Lifecycle
    closed       chan struct{}
    wg           sync.WaitGroup
}
```

3. NewBWEInterceptor constructor:
```go
func NewBWEInterceptor(estimator *bwe.BandwidthEstimator, opts ...InterceptorOption) *BWEInterceptor {
    i := &BWEInterceptor{
        estimator:    estimator,
        closed:       make(chan struct{}),
        rembInterval: time.Second,  // default 1Hz
    }
    for _, opt := range opts {
        opt(i)
    }
    return i
}
```

4. InterceptorOption type for configuration:
```go
type InterceptorOption func(*BWEInterceptor)

func WithREMBInterval(d time.Duration) InterceptorOption {
    return func(i *BWEInterceptor) {
        i.rembInterval = d
    }
}

func WithSenderSSRC(ssrc uint32) InterceptorOption {
    return func(i *BWEInterceptor) {
        i.senderSSRC = ssrc
    }
}
```
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...` to verify compilation</verify>
  <done>BWEInterceptor type exists with NoOp embedding and constructor</done>
</task>

<task type="auto">
  <name>Task 2: Implement BindRemoteStream</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Add BindRemoteStream and UnbindRemoteStream methods to BWEInterceptor:

1. BindRemoteStream(info *interceptor.StreamInfo, reader interceptor.RTPReader) interceptor.RTPReader:
   - Extract extension IDs from info.RTPHeaderExtensions using helpers from extension.go
   - Store extension IDs atomically (only update if not already set, first stream wins)
   - Create streamState and store in sync.Map keyed by info.SSRC
   - Return RTPReaderFunc wrapper that calls processRTP after reading

```go
func (i *BWEInterceptor) BindRemoteStream(info *interceptor.StreamInfo, reader interceptor.RTPReader) interceptor.RTPReader {
    // Extract extension IDs (first stream to provide them wins)
    if absID := FindAbsSendTimeID(info.RTPHeaderExtensions); absID != 0 {
        i.absExtID.CompareAndSwap(0, uint32(absID))
    }
    if captureID := FindAbsCaptureTimeID(info.RTPHeaderExtensions); captureID != 0 {
        i.captureExtID.CompareAndSwap(0, uint32(captureID))
    }

    // Track stream
    state := newStreamState(info.SSRC)
    i.streams.Store(info.SSRC, state)

    // Return observing reader
    return interceptor.RTPReaderFunc(func(b []byte, a interceptor.Attributes) (int, interceptor.Attributes, error) {
        n, a, err := reader.Read(b, a)
        if err == nil && n > 0 {
            i.processRTP(b[:n], info.SSRC)
        }
        return n, a, err
    })
}
```

2. UnbindRemoteStream(info *interceptor.StreamInfo):
   - Delete stream from sync.Map

```go
func (i *BWEInterceptor) UnbindRemoteStream(info *interceptor.StreamInfo) {
    i.streams.Delete(info.SSRC)
}
```

IMPORTANT: Keep RTP path non-blocking. processRTP should be fast (parsing + estimator call).
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>BindRemoteStream extracts extension IDs and wraps reader</done>
</task>

<task type="auto">
  <name>Task 3: Implement processRTP</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Add processRTP method that parses RTP and feeds estimator:

```go
func (i *BWEInterceptor) processRTP(raw []byte, ssrc uint32) {
    // Parse RTP header
    var header rtp.Header
    if _, err := header.Unmarshal(raw); err != nil {
        return // Invalid RTP, skip
    }

    now := time.Now()

    // Update stream state
    if state, ok := i.streams.Load(ssrc); ok {
        state.(*streamState).UpdateLastPacket(now)
    }

    // Get extension IDs
    absID := uint8(i.absExtID.Load())
    captureID := uint8(i.captureExtID.Load())

    // Try abs-send-time first (preferred, 3 bytes)
    var sendTime uint32
    if absID != 0 {
        if ext := header.GetExtension(absID); len(ext) >= 3 {
            sendTime, _ = bwe.ParseAbsSendTime(ext)
        }
    }

    // Fallback to abs-capture-time (8 bytes, convert to abs-send-time scale)
    if sendTime == 0 && captureID != 0 {
        if ext := header.GetExtension(captureID); len(ext) >= 8 {
            captureTime, err := bwe.ParseAbsCaptureTime(ext)
            if err == nil {
                // Convert 64-bit UQ32.32 to 24-bit 6.18 fixed point
                // Take upper 24 bits of the 32-bit fractional seconds representation
                // AbsCaptureTime: upper 32 bits = seconds, lower 32 bits = fraction
                // We need seconds (6 bits) + fraction (18 bits) = 24 bits total
                // Extract: (seconds mod 64) << 18 | (fraction >> 14)
                seconds := (captureTime >> 32) & 0x3F  // 6 bits of seconds (mod 64)
                fraction := (captureTime >> 14) & 0x3FFFF  // 18 bits of fraction
                sendTime = uint32((seconds << 18) | fraction)
            }
        }
    }

    // No timing extension found, skip packet
    if sendTime == 0 {
        return
    }

    // Feed to estimator
    pkt := bwe.PacketInfo{
        ArrivalTime: now,
        SendTime:    sendTime,
        Size:        len(raw),
        SSRC:        ssrc,
    }
    i.estimator.OnPacket(pkt)
}
```

Key points:
- Use time.Now() for monotonic arrival time
- abs-send-time takes priority (more common)
- abs-capture-time conversion preserves the 6.18 format expected by estimator
- Gracefully skip packets without timing extensions
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>processRTP parses headers, extracts timing, calls estimator.OnPacket</done>
</task>

<task type="auto">
  <name>Task 4: Add unit tests</name>
  <files>pkg/bwe/interceptor/interceptor_test.go</files>
  <action>
Create pkg/bwe/interceptor/interceptor_test.go with:

1. Test helper to create RTP packet with abs-send-time extension:
```go
func makeRTPWithAbsSendTime(ssrc uint32, sendTime uint32) []byte {
    // Create RTP packet with one-byte header extension
    // Extension ID 3 (commonly used for abs-send-time), 3 bytes
    // Use pion/rtp to build properly formatted packet
}
```

2. TestBindRemoteStream_ExtractsExtensionIDs:
   - Create interceptor
   - Call BindRemoteStream with StreamInfo containing abs-send-time extension
   - Verify absExtID is set correctly

3. TestProcessRTP_FeedsEstimator:
   - Create interceptor with test BandwidthEstimator
   - Simulate reading RTP packet with abs-send-time
   - Verify estimator.OnPacket was called (check GetSSRCs includes the SSRC)

4. TestProcessRTP_NoExtension_Skips:
   - Process RTP without timing extension
   - Verify estimator state unchanged

5. TestMultipleStreams_TrackedSeparately:
   - Bind two streams with different SSRCs
   - Verify both tracked in streams map

Import `github.com/stretchr/testify/assert` and `github.com/stretchr/testify/require`.
  </action>
  <verify>Run `go test ./pkg/bwe/interceptor/... -v`</verify>
  <done>Unit tests pass for BindRemoteStream and processRTP</done>
</task>

</tasks>

<verification>
```bash
# Build interceptor package
go build ./pkg/bwe/interceptor/...

# Run tests
go test ./pkg/bwe/interceptor/... -v

# Check for race conditions
go test ./pkg/bwe/interceptor/... -race

# Verify no import cycles
go vet ./pkg/bwe/interceptor/...
```
</verification>

<success_criteria>
- BWEInterceptor type with NoOp embedding compiles
- BindRemoteStream extracts extension IDs and wraps reader
- processRTP parses RTP headers and calls estimator.OnPacket
- Both abs-send-time and abs-capture-time supported
- Unit tests pass including race detector
</success_criteria>

<output>
After completion, create `.planning/phases/03-pion-integration/03-02-SUMMARY.md`
</output>
