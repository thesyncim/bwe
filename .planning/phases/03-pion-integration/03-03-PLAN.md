---
phase: 03-pion-integration
plan: 03
type: execute
wave: 3
depends_on: ["03-02"]
files_modified:
  - pkg/bwe/interceptor/interceptor.go
  - pkg/bwe/interceptor/interceptor_test.go
autonomous: true

must_haves:
  truths:
    - "BindRTCPWriter captures the writer for REMB sending"
    - "REMB packets are sent at configurable intervals (default 1Hz)"
    - "REMB packets include all tracked SSRCs"
    - "Writer not being bound yet is handled gracefully"
  artifacts:
    - path: "pkg/bwe/interceptor/interceptor.go"
      provides: "BindRTCPWriter and rembLoop implementation"
      exports: ["BindRTCPWriter"]
  key_links:
    - from: "pkg/bwe/interceptor/interceptor.go"
      to: "interceptor.RTCPWriter"
      via: "writer.Write in sendREMB"
      pattern: "rtcpWriter\\.Write"
    - from: "pkg/bwe/interceptor/interceptor.go"
      to: "pkg/bwe.REMBScheduler"
      via: "MaybeSendREMB call"
      pattern: "rembScheduler\\.MaybeSendREMB|MaybeBuildREMB"
---

<objective>
Implement BindRTCPWriter and the REMB sending loop for periodic bandwidth feedback.

Purpose: Enable the interceptor to send REMB packets to the sender at configurable intervals, using the bandwidth estimate from the BandwidthEstimator and the existing REMBScheduler from Phase 2.

Output:
- BindRTCPWriter implementation that starts the REMB goroutine
- rembLoop goroutine for periodic REMB sending
- sendREMB method that uses RTCPWriter correctly
- Tests verifying REMB timing and content
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-pion-integration/03-RESEARCH.md

Key points from research:
- RTCPWriter.Write takes []rtcp.Packet, not raw bytes
- Use rtcp.ReceiverEstimatedMaximumBitrate directly (or unmarshal from bytes)
- Start REMB goroutine in BindRTCPWriter
- Check rtcpWriter != nil before sending (may not be bound yet)
- Use time.Ticker for periodic sending

Existing API from Phase 2:
- bwe.REMBScheduler with MaybeSendREMB(estimate, ssrcs, time) -> (bytes, bool, error)
- bwe.BandwidthEstimator.GetEstimate() int64
- bwe.BandwidthEstimator.GetSSRCs() []uint32
- bwe.BandwidthEstimator.SetREMBScheduler(*REMBScheduler)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add REMB scheduler to interceptor</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Update BWEInterceptor to include REMB scheduler:

1. Add rembScheduler field to BWEInterceptor struct:
```go
type BWEInterceptor struct {
    // ... existing fields ...
    rembScheduler *bwe.REMBScheduler
}
```

2. Update NewBWEInterceptor to create and attach REMBScheduler:
```go
func NewBWEInterceptor(estimator *bwe.BandwidthEstimator, opts ...InterceptorOption) *BWEInterceptor {
    i := &BWEInterceptor{
        estimator:    estimator,
        closed:       make(chan struct{}),
        rembInterval: time.Second,
    }
    for _, opt := range opts {
        opt(i)
    }

    // Create and attach REMB scheduler
    rembConfig := bwe.DefaultREMBSchedulerConfig()
    rembConfig.Interval = i.rembInterval
    rembConfig.SenderSSRC = i.senderSSRC
    i.rembScheduler = bwe.NewREMBScheduler(rembConfig)
    i.estimator.SetREMBScheduler(i.rembScheduler)

    return i
}
```

This wires up the Phase 2 REMBScheduler with the interceptor's REMB interval.
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>REMB scheduler is created and attached to estimator</done>
</task>

<task type="auto">
  <name>Task 2: Implement BindRTCPWriter</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Add BindRTCPWriter method:

```go
func (i *BWEInterceptor) BindRTCPWriter(writer interceptor.RTCPWriter) interceptor.RTCPWriter {
    i.mu.Lock()
    i.rtcpWriter = writer
    i.mu.Unlock()

    // Start REMB loop goroutine
    i.wg.Add(1)
    go i.rembLoop()

    return writer  // Pass through unchanged
}
```

Key points:
- Capture writer under lock (may be accessed by rembLoop)
- Start single goroutine for REMB sending
- Return writer unchanged (interceptor observes, doesn't modify RTCP)
- wg.Add before goroutine start for proper Close() cleanup
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>BindRTCPWriter captures writer and starts rembLoop</done>
</task>

<task type="auto">
  <name>Task 3: Implement rembLoop</name>
  <files>pkg/bwe/interceptor/interceptor.go</files>
  <action>
Add rembLoop method:

```go
func (i *BWEInterceptor) rembLoop() {
    defer i.wg.Done()

    ticker := time.NewTicker(i.rembInterval)
    defer ticker.Stop()

    for {
        select {
        case <-i.closed:
            return
        case now := <-ticker.C:
            i.maybeSendREMB(now)
        }
    }
}

func (i *BWEInterceptor) maybeSendREMB(now time.Time) {
    // Get REMB data using estimator's scheduler
    data, shouldSend, err := i.estimator.MaybeBuildREMB(now)
    if err != nil || !shouldSend || len(data) == 0 {
        return
    }

    // Get writer under lock
    i.mu.Lock()
    writer := i.rtcpWriter
    i.mu.Unlock()

    if writer == nil {
        return  // Not bound yet, skip
    }

    // Parse bytes back to RTCP packet for RTCPWriter interface
    // RTCPWriter.Write takes []rtcp.Packet, not raw bytes
    pkts, err := rtcp.Unmarshal(data)
    if err != nil {
        return  // Should never happen with our own REMB bytes
    }

    // Send REMB
    _, _ = writer.Write(pkts, nil)  // Ignore errors (network issues)
}
```

Add import for `github.com/pion/rtcp`.

Key points:
- Uses estimator.MaybeBuildREMB which integrates with REMBScheduler
- REMBScheduler handles immediate-on-decrease logic
- Unmarshal our REMB bytes back to rtcp.Packet for Write interface
- Ignore write errors (network issues shouldn't stop the loop)
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...`</verify>
  <done>rembLoop sends REMB at configured intervals using RTCPWriter</done>
</task>

<task type="auto">
  <name>Task 4: Add REMB tests</name>
  <files>pkg/bwe/interceptor/interceptor_test.go</files>
  <action>
Add tests for REMB functionality:

1. Create mock RTCPWriter:
```go
type mockRTCPWriter struct {
    mu      sync.Mutex
    packets []rtcp.Packet
}

func (m *mockRTCPWriter) Write(pkts []rtcp.Packet, _ interceptor.Attributes) (int, error) {
    m.mu.Lock()
    defer m.mu.Unlock()
    m.packets = append(m.packets, pkts...)
    return len(pkts), nil
}

func (m *mockRTCPWriter) getPackets() []rtcp.Packet {
    m.mu.Lock()
    defer m.mu.Unlock()
    result := make([]rtcp.Packet, len(m.packets))
    copy(result, m.packets)
    return result
}
```

2. TestBindRTCPWriter_StartsREMBLoop:
   - Create interceptor with short rembInterval (100ms)
   - Bind mock RTCPWriter
   - Process some RTP packets to generate estimate
   - Wait for 2-3 intervals
   - Verify REMB packets were written
   - Close interceptor

3. TestREMB_IncludesAllSSRCs:
   - Process packets from multiple SSRCs
   - Wait for REMB
   - Verify REMB packet contains all SSRCs

4. TestREMB_WriterNotBound_NoError:
   - Create interceptor without binding RTCPWriter
   - Call maybeSendREMB directly
   - Verify no panic, no error

5. TestREMB_ImmediateOnDecrease:
   - Set up scenario where estimate decreases significantly
   - Verify REMB sent before next interval tick
   (This is handled by REMBScheduler from Phase 2)
  </action>
  <verify>Run `go test ./pkg/bwe/interceptor/... -v -race`</verify>
  <done>REMB tests pass including race detector</done>
</task>

</tasks>

<verification>
```bash
# Build package
go build ./pkg/bwe/interceptor/...

# Run all tests with race detector
go test ./pkg/bwe/interceptor/... -v -race

# Run specific REMB tests
go test ./pkg/bwe/interceptor/... -v -run REMB

# Verify REMB timing (should see packets at ~1s intervals by default)
go test ./pkg/bwe/interceptor/... -v -run TestBindRTCPWriter
```
</verification>

<success_criteria>
- BindRTCPWriter captures writer and starts goroutine
- REMB packets sent at configured intervals (default 1s)
- REMB uses RTCPWriter interface correctly ([]rtcp.Packet)
- All tracked SSRCs included in REMB
- Graceful handling when writer not bound
- Tests pass with race detector
</success_criteria>

<output>
After completion, create `.planning/phases/03-pion-integration/03-03-SUMMARY.md`
</output>
