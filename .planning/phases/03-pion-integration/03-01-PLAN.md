---
phase: 03-pion-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - pkg/bwe/interceptor/extension.go
  - pkg/bwe/interceptor/stream.go
autonomous: true

must_haves:
  truths:
    - "Extension IDs can be extracted from StreamInfo.RTPHeaderExtensions"
    - "Both abs-send-time and abs-capture-time URIs are recognized"
    - "Stream state tracks SSRC and last packet time"
  artifacts:
    - path: "pkg/bwe/interceptor/extension.go"
      provides: "Extension URI constants and ID lookup"
      exports: ["AbsSendTimeURI", "AbsCaptureTimeURI", "FindExtensionID"]
    - path: "pkg/bwe/interceptor/stream.go"
      provides: "Per-stream state tracking"
      exports: ["streamState"]
  key_links:
    - from: "pkg/bwe/interceptor/extension.go"
      to: "github.com/pion/interceptor.RTPHeaderExtension"
      via: "URI matching in FindExtensionID"
      pattern: "ext\\.URI.*AbsSendTimeURI"
---

<objective>
Set up the Pion interceptor package with dependencies and foundational types.

Purpose: Establish the pkg/bwe/interceptor directory structure and provide extension ID lookup helpers that will be used by the interceptor to extract timing information from RTP packets.

Output:
- pion/interceptor and pion/rtp dependencies added to go.mod
- extension.go with URI constants and FindExtensionID helper
- stream.go with streamState type for tracking per-stream state
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-pion-integration/03-RESEARCH.md

Key points from research:
- Extension URIs: "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time" and "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time"
- StreamInfo.RTPHeaderExtensions provides extension ID -> URI mapping from SDP
- Use interceptor.RTPHeaderExtension type for matching
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Pion dependencies</name>
  <files>go.mod, go.sum</files>
  <action>
Add the required Pion dependencies for interceptor implementation:

```bash
go get github.com/pion/interceptor@v0.1.43
go get github.com/pion/rtp@latest
```

Verify go.mod includes:
- github.com/pion/interceptor v0.1.43
- github.com/pion/rtp (any recent version, likely v1.8+)

Note: pion/rtcp is already in go.mod from Phase 2.
  </action>
  <verify>Run `go mod tidy && go build ./...` to verify dependencies resolve correctly</verify>
  <done>go.mod has pion/interceptor and pion/rtp dependencies, project builds</done>
</task>

<task type="auto">
  <name>Task 2: Create extension ID lookup helpers</name>
  <files>pkg/bwe/interceptor/extension.go</files>
  <action>
Create pkg/bwe/interceptor/extension.go with:

1. Package declaration: `package interceptor`

2. Import `github.com/pion/interceptor`

3. Extension URI constants:
   - `AbsSendTimeURI = "http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time"`
   - `AbsCaptureTimeURI = "http://www.webrtc.org/experiments/rtp-hdrext/abs-capture-time"`

4. `FindExtensionID(exts []interceptor.RTPHeaderExtension, uri string) uint8` function:
   - Iterates through exts
   - Returns uint8(ext.ID) when ext.URI matches uri
   - Returns 0 if not found (0 is invalid extension ID)

5. Helper functions for convenience:
   - `FindAbsSendTimeID(exts []interceptor.RTPHeaderExtension) uint8`
   - `FindAbsCaptureTimeID(exts []interceptor.RTPHeaderExtension) uint8`

Document that extension ID 0 means "not found" and should be handled gracefully.
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...` to verify compilation</verify>
  <done>extension.go exists with URI constants and FindExtensionID function</done>
</task>

<task type="auto">
  <name>Task 3: Create stream state type</name>
  <files>pkg/bwe/interceptor/stream.go</files>
  <action>
Create pkg/bwe/interceptor/stream.go with:

1. Package declaration: `package interceptor`

2. Import `time` and `sync/atomic`

3. `streamState` struct (unexported, internal use):
   - `ssrc uint32` - Stream SSRC
   - `lastPacketTime atomic.Value` - stores time.Time of last packet (atomic for concurrent access)

4. Constructor `newStreamState(ssrc uint32) *streamState`:
   - Creates streamState
   - Initializes lastPacketTime to current time

5. Methods on streamState:
   - `UpdateLastPacket(t time.Time)` - stores time atomically
   - `LastPacket() time.Time` - loads time atomically
   - `SSRC() uint32` - returns ssrc

Use atomic.Value for lastPacketTime because:
- BindRemoteStream reader updates it on every packet
- cleanupLoop reads it periodically
- Both happen concurrently without explicit locking
  </action>
  <verify>Run `go build ./pkg/bwe/interceptor/...` to verify compilation</verify>
  <done>stream.go exists with streamState type and atomic lastPacketTime</done>
</task>

</tasks>

<verification>
```bash
# Verify package builds
go build ./pkg/bwe/interceptor/...

# Verify dependencies are correct
go mod tidy
go list -m github.com/pion/interceptor
go list -m github.com/pion/rtp

# Verify no import cycles
go vet ./pkg/bwe/interceptor/...
```
</verification>

<success_criteria>
- pion/interceptor and pion/rtp dependencies in go.mod
- pkg/bwe/interceptor/extension.go with FindExtensionID function
- pkg/bwe/interceptor/stream.go with streamState type
- Package compiles without errors
- No import cycles (interceptor package only imports pion packages, not bwe core)
</success_criteria>

<output>
After completion, create `.planning/phases/03-pion-integration/03-01-SUMMARY.md`
</output>
